This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: WorkTrackApi
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
WorkTrackApi/__init__.py
WorkTrackApi/admin.py
WorkTrackApi/apps.py
WorkTrackApi/code_test.py
WorkTrackApi/export.py
WorkTrackApi/management/__inyt__.py
WorkTrackApi/management/commands/check_missing_attendance.py
WorkTrackApi/migrations/__init__.py
WorkTrackApi/migrations/0001_initial.py
WorkTrackApi/migrations/0002_typeshift.py
WorkTrackApi/migrations/0003_alter_typeshift_nameshift_attendance.py
WorkTrackApi/migrations/0004_changereason_plannedshifts.py
WorkTrackApi/migrations/0005_alter_typeshift_nameshift.py
WorkTrackApi/migrations/0006_alter_attendance_unique_together.py
WorkTrackApi/migrations/0007_plannedshifts_transferred.py
WorkTrackApi/migrations/0008_alter_plannedshifts_change_reason.py
WorkTrackApi/migrations/0009_alter_plannedshifts_unique_together.py
WorkTrackApi/migrations/0010_attendance_exchanged_with.py
WorkTrackApi/migrations/0011_calendarday.py
WorkTrackApi/migrations/0012_calendarday_holiday_name.py
WorkTrackApi/migrations/0013_attendance_calendar_day_plannedshifts_calendar_day.py
WorkTrackApi/migrations/0014_remove_changereason_code_changereason_category_and_more.py
WorkTrackApi/migrations/0015_typeshift_allow_variable_time_and_more.py
WorkTrackApi/migrations/0016_alter_plannedshifts_calendar_day_and_more.py
WorkTrackApi/migrations/0017_plannedshifts_hidden.py
WorkTrackApi/migrations/0018_attendance_planned_shift_and_more.py
WorkTrackApi/migrations/0019_alter_plannedshifts_date.py
WorkTrackApi/migrations/0020_alter_attendance_options_alter_attendance_date_and_more.py
WorkTrackApi/migrations/0021_alter_typeshift_duration_time_and_more.py
WorkTrackApi/migrations/0022_typeshift_shortname.py
WorkTrackApi/migrations/0023_alter_plannedshifts_user.py
WorkTrackApi/migrations/0024_alter_plannedshifts_calendar_day.py
WorkTrackApi/migrations/0025_employees_initial_hours_balance.py
WorkTrackApi/migrations/0026_plannedshifts_approval_status_and_more.py
WorkTrackApi/models.py
WorkTrackApi/permissions.py
WorkTrackApi/serializers.py
WorkTrackApi/services.py
WorkTrackApi/signals.py
WorkTrackApi/tests.py
WorkTrackApi/urls.py
WorkTrackApi/utils/__init__.py
WorkTrackApi/utils/attendance_utils.py
WorkTrackApi/views.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="WorkTrackApi/__init__.py">

</file>

<file path="WorkTrackApi/admin.py">
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin
from django.utils.translation import gettext_lazy as _
from .models import Employees, TypeShift,Attendance, PlannedShifts, CalendarDay, ChangeReason
from .utils.attendance_utils import create_attendance_from_planned_shift

@admin.register(Employees)
class EmployeesAdmin(UserAdmin):
    model = Employees
    readonly_fields = ("id",)
    fieldsets = (
        (None, {"fields": ("id","username", "password")}),
        (_("Osobné údaje"), {"fields": ("first_name", "last_name",'initial_hours_balance', "email", "personal_number", "role")}),
        (_("Oprávnenia"), {"fields": ("is_active", "is_staff", "is_superuser", "groups", "user_permissions")}),
        (_("Dôležité dátumy"), {"fields": ("last_login", "date_joined")}),
    )

    add_fieldsets = (
        (None, {
            "classes": ("wide",),
            "fields": (
                "username", "password1", "password2",
                "email", "first_name", "last_name", "personal_number", "role"
            ),
        }),
    )

    list_display = ("id",'username', 'email', 'first_name', 'last_name', 'personal_number', 'role', 'is_staff', 'is_active')
    search_fields = ('username', 'email', 'first_name', 'last_name', 'personal_number')
    ordering = ('username',)



@admin.register(Attendance)
class AttendanceAdmin(admin.ModelAdmin):
    list_display = ('id','user', 'date', 'type_shift', 'custom_start','planned_shift', 'custom_end', 'note', 'exchanged_with')
    list_filter = ('user', 'type_shift','exchanged_with')
    list_display_links = ('id', 'user')
    search_fields = ('user__username', 'note')

    def save_model(self, request, obj, form, change):
        # Zaokrúhli časy, ak sú zadané
        if obj.custom_start:
            obj.custom_start = obj.round_to_nearest_half_hour(obj.custom_start)
        if obj.custom_end:
            obj.custom_end = obj.round_to_nearest_half_hour(obj.custom_end)

        # Ak je to nový záznam a má zvolenú plánovanú smenu, vytvor ho podľa nej
        if not change and obj.planned_shift_id:
            attendance = create_attendance_from_planned_shift(
                
                user=obj.user,
                date=obj.date,
                planned_shift_id=obj.planned_shift_id
            )
            if attendance:
                print("✅ Attendance vytvorený podľa plánovanej smeny.")
                return  # Už sme vytvorili nový záznam, nič ďalšie netreba

        # Inak bežné uloženie
        super().save_model(request, obj, form, change)


@admin.register(PlannedShifts)
class PlannedShiftsAdmin(admin.ModelAdmin):
    
    list_display = ('id','user', 'date', 'type_shift', 'custom_start', 'custom_end','note', 'transferred', 'is_changed','hidden', 'change_reason','change_reason', 'approval_status',)
    list_filter = ('user', 'type_shift')
    list_display_links = ('id', 'user')

@admin.register(TypeShift)
class TypeShiftsAdmin(admin.ModelAdmin):
    
    list_display = ('id', 'nameShift', 'start_time', 'end_time', 'duration_time','allow_variable_time','shortName')
    list_filter = ('id','nameShift')

@admin.register(CalendarDay)
class CalendarDayAdmin(admin.ModelAdmin):
    list_display = ("date", "day", "is_weekend", "is_holiday", "holiday_name")
    list_filter = ("is_weekend", "is_holiday")
    search_fields = ("day", "holiday_name")

@admin.register(ChangeReason)
class ChangeReasonAdmin(admin.ModelAdmin):
    list_display = ("name", "description", "category")
</file>

<file path="WorkTrackApi/apps.py">
from django.apps import AppConfig

class WorkTrackApiConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'WorkTrackApi'

    def ready(self):
        # Načítanie signálov (aby fungovali triggery ako create_auth_token)
        import WorkTrackApi.signals
</file>

<file path="WorkTrackApi/code_test.py">
# def reset_auto_changed_attendance():
#     auto_records = PlannedShifts.objects.filter(
#         user=user,
#         date=date,
#         hidden=False,
#         is_changed=True,
#         note__icontains="Chýbajúca dochádzka k plánovanej smene"
#     )
#     updated_count = auto_records.update(is_changed=False, note="")


#     print(f"Resetovaných {updated_count} automatických záznamov plánovaných smien.")
</file>

<file path="WorkTrackApi/export.py">
from reportlab.lib import colors
from reportlab.lib.pagesizes import A4, landscape
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import mm
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
import os
from io import BytesIO
import openpyxl
from openpyxl.styles import Font, Alignment, Border, Side, PatternFill
from openpyxl.utils import get_column_letter
from django.http import HttpResponse
from rest_framework.exceptions import ValidationError
from datetime import date, datetime, timedelta, time
from calendar import monthrange
from .models import Attendance, Employees, CalendarDay,PlannedShifts,TypeShift
class MonthlyRosterExporter:
    def __init__(self, year, month):
        self.year = year
        self.month = month
        self.wb = openpyxl.Workbook()
        self.ws = self.wb.active
        self.ws.title = f"Rozpis {month}-{year}"
        
        # Konštanty a štýly
        self.thin = Side(style='thin')
        self.thick = Side(style='medium')
        self.bold_font = Font(bold=True)
        self.title_font = Font(bold=True, size=14)
        self.center_align = Alignment(horizontal='center', vertical='center')
        self.right_align = Alignment(horizontal='right', vertical='center')
        self.vertical_align = Alignment(horizontal='center', vertical='center', textRotation=90)
        self.gray_fill = PatternFill(start_color="DDDDDD", end_color="DDDDDD", fill_type="solid")
        
        # Mapovania
        self.SHIFT_TO_COLUMN_MAP = {
            23: 'Ič', 21: 'Do', 16: 'D', 13: 'D', 15: 'D', 14: 'D',
            19: 'Pp', 17: 'Pp', 18: 'Pp', 20: 'Ns', 
            8: 'SN', 9: 'SN', 11: 'SN', 12: 'SN', 10: 'SN', 22: 'Ič',
        }
        self.ID_TO_TEXT_MAP = {21: 'DO', 23: 'PN'}
        self.SUB_COLUMNS = ['SN', 'Do', 'Pp', 'Ič', 'D', 'Ns']
        self.NON_WORKING_IDS = [21, 23]

    def _get_shift_duration(self, s_start, s_end):
        if not (s_start and s_end): return 0.0
        dt_s = datetime.combine(date(2000, 1, 1), s_start)
        dt_e = datetime.combine(date(2000, 1, 1), s_end)
        if dt_e < dt_s: dt_e += timedelta(days=1)
        if s_end == time(0, 0) and s_start != s_end: dt_e += timedelta(days=1)
        return (dt_e - dt_s).total_seconds() / 3600.0

    def _calculate_overlap_seconds(self, start1, end1, start2, end2):
        latest_start = max(start1, start2)
        earliest_end = min(end1, end2)
        return max(0.0, (earliest_end - latest_start).total_seconds())

    def generate_response(self):
        """Hlavná metóda, ktorá spustí generovanie a vráti HTTP Response"""
        
        # 1. Príprava dát
        slovak_months = ["", "Január", "Február", "Marec", "Apríl", "Máj", "Jún", 
                         "Júl", "August", "September", "Október", "November", "December"]
        month_name = slovak_months[self.month]
        
        holidays_dates = set(val[0] for val in CalendarDay.get_slovak_holidays(self.year))
        days_in_month = monthrange(self.year, self.month)[1]
        start_date = date(self.year, self.month, 1)
        end_date = date(self.year, self.month, days_in_month)

        work_days_count = sum(1 for d in range(1, days_in_month + 1) 
                              if date(self.year, self.month, d).weekday() < 5 and date(self.year, self.month, d) not in holidays_dates)
        
        STANDARD_HOURS = 7.0
        work_fund = work_days_count * STANDARD_HOURS

        # 2. Načítanie zamestnancov (Filter)
        active_ids_in_month = PlannedShifts.objects.filter(
            date__range=(start_date, end_date), hidden=False
        ).values_list('user_id', flat=True).distinct()

        employees = Employees.objects.filter(id__in=active_ids_in_month).order_by('last_name')
        
        if not employees.exists():
            raise ValidationError(detail=f"Pre obdobie {self.month}/{self.year} neboli nájdené žiadne platné smeny na export.")
        
        num_emps = employees.count()
        last_col_idx = 2 + (num_emps * 6)

        # 3. Vykreslenie HLAVIČKY
        self.ws.merge_cells(start_row=1, start_column=1, end_row=1, end_column=last_col_idx)
        self.ws.cell(row=1, column=1, value=f"Rozdeľovník služieb 5.SuS {month_name} {self.year}").font = self.title_font
        self.ws.cell(row=1, column=1).alignment = self.center_align

        self.ws.merge_cells(start_row=2, start_column=1, end_row=2, end_column=4)
        self.ws.cell(row=2, column=1, value="Počet pracovných dní:").font = self.bold_font
        self.ws.cell(row=2, column=5, value=work_days_count).alignment = self.center_align

        mid_col = max(5, last_col_idx // 2)
        self.ws.cell(row=2, column=mid_col, value=month_name).font = self.bold_font
        self.ws.cell(row=2, column=mid_col).alignment = self.center_align

        self.ws.merge_cells(start_row=2, start_column=last_col_idx-3, end_row=2, end_column=last_col_idx-1)
        self.ws.cell(row=2, column=last_col_idx-3, value="Úväzok v hod.:").font = self.bold_font
        self.ws.cell(row=2, column=last_col_idx-3).alignment = self.right_align
        self.ws.cell(row=2, column=last_col_idx, value=work_fund).alignment = self.center_align

        # 4. Vykreslenie MENÁ A TABUĽKA
        NAME_ROW, SUB_HEADER_ROW, DATA_START_ROW = 4, 5, 6

        # Vertikálne nadpisy Dátum/Deň
        for col_idx, val in enumerate(["Dátum", "Deň"], start=1):
            self.ws.merge_cells(start_row=NAME_ROW, start_column=col_idx, end_row=SUB_HEADER_ROW, end_column=col_idx)
            c = self.ws.cell(row=NAME_ROW, column=col_idx, value=val)
            c.alignment = self.vertical_align
            c.font = Font(size=9, bold=True)
            # Rámčeky Dátum/Deň
            c.border = Border(top=self.thick, left=(self.thick if col_idx==1 else self.thin), 
                              right=(self.thick if col_idx==2 else self.thin))
            self.ws.cell(row=SUB_HEADER_ROW, column=col_idx).border = Border(bottom=self.thick, 
                              left=(self.thick if col_idx==1 else self.thin), 
                              right=(self.thick if col_idx==2 else self.thin))

        emp_col_start, current_col = {}, 3
        
        # Slučka cez zamestnancov (Hlavička)
        border_thick_box = Border(left=self.thick, right=self.thick, top=self.thick, bottom=self.thick)
        
        for emp in employees:
            self.ws.merge_cells(start_row=NAME_ROW, start_column=current_col, end_row=NAME_ROW, end_column=current_col + 5)
            c = self.ws.cell(row=NAME_ROW, column=current_col, value=f"{emp.last_name} {emp.first_name[0]}.")
            c.font = self.bold_font
            c.alignment = self.center_align
            for i in range(6): self.ws.cell(row=NAME_ROW, column=current_col + i).border = border_thick_box
            
            for i, col_name in enumerate(self.SUB_COLUMNS):
                actual_col = current_col + i
                c = self.ws.cell(row=SUB_HEADER_ROW, column=actual_col, value=col_name)
                c.alignment = self.center_align
                c.font = Font(size=8)
                self.ws.column_dimensions[get_column_letter(actual_col)].width = 4
                
                b_left = self.thick if i == 0 else self.thin
                b_right = self.thick if i == 5 else self.thin
                c.border = Border(left=b_left, right=b_right, top=self.thin, bottom=self.thick)

            emp_col_start[emp.id] = current_col
            current_col += 6

        # 5. DÁTA (Mriežka a Smeny)
        shifts = PlannedShifts.objects.filter(date__range=(start_date, end_date), hidden=False).select_related('type_shift')
        shift_data = {}
        for s in shifts:
            d_iso = s.date.isoformat()
            shift_data.setdefault(d_iso, {}).setdefault(s.user_id, []).append(s)

        slovak_days = ['Po', 'Ut', 'St', 'Št', 'Pi', 'So', 'Ne']
        for day in range(1, days_in_month + 1):
            row_idx = day + DATA_START_ROW - 1
            curr_date = date(self.year, self.month, day)
            d_iso = curr_date.isoformat()
            is_weekend = curr_date.weekday() >= 5
            
            # Prvé dva stĺpce
            self.ws.cell(row=row_idx, column=1, value=f"{day}.").border = Border(left=self.thick, right=self.thin, top=self.thin, bottom=self.thin)
            self.ws.cell(row=row_idx, column=2, value=slovak_days[curr_date.weekday()]).border = Border(left=self.thin, right=self.thick, top=self.thin, bottom=self.thin)
            if is_weekend:
                for c_idx in [1, 2]: self.ws.cell(row=row_idx, column=c_idx).fill = self.gray_fill

            # Mriežka zamestnancov
            for col in range(3, current_col):
                cell = self.ws.cell(row=row_idx, column=col)
                pos = (col - 3) % 6
                cell.border = Border(left=(self.thick if pos == 0 else self.thin), right=(self.thick if pos == 5 else self.thin), 
                                     top=self.thin, bottom=(self.thick if day == days_in_month else self.thin))
                if is_weekend: cell.fill = self.gray_fill

            # Vyplnenie smien
            if d_iso in shift_data:
                for user_id, user_shifts in shift_data[d_iso].items():
                    start_col = emp_col_start.get(user_id)
                    if not start_col: continue 
                    for shift in user_shifts:
                        if not shift.type_shift or (shift.type_shift.id == 20 and shift.custom_start == time(0, 0)): continue
                        target_col = self.SHIFT_TO_COLUMN_MAP.get(shift.type_shift.id) or (shift.type_shift.shortName if shift.type_shift.shortName in self.SUB_COLUMNS else None)
                        if not target_col: continue
                        final_col = start_col + self.SUB_COLUMNS.index(target_col)
                        
                        val = self.ID_TO_TEXT_MAP.get(shift.type_shift.id)
                        if val is None:
                            val = float(shift.type_shift.duration_time) if shift.type_shift.duration_time else self._get_shift_duration(shift.custom_start, shift.custom_end)
                            if val == 0: val = ""
                            elif val % 1 == 0: val = int(val)
                            else: val = round(val, 2)

                        cell = self.ws.cell(row=row_idx, column=final_col, value=val)
                        cell.alignment = self.center_align
                        # Obnova rámu po zápise
                        pos = (final_col - 3) % 6
                        cell.border = Border(left=(self.thick if pos == 0 else self.thin), right=(self.thick if pos == 5 else self.thin), 
                                             top=self.thin, bottom=(self.thick if day == days_in_month else self.thin))
                        if is_weekend: cell.fill = self.gray_fill

        # 6. SUMÁRNE VÝPOČTY
        SUMMARY_START_ROW = days_in_month + DATA_START_ROW + 1
        labels = ["Prenesené hodiny:", "Odpracované hodiny:", "+/- za mesiac:", "SPOLU za mesiac:", "Sviatky:", "Sobota:", "Nedeľa:", "Nočná smena:"]
        
        for i, label in enumerate(labels):
            row = SUMMARY_START_ROW + i
            self.ws.merge_cells(start_row=row, start_column=1, end_row=row, end_column=2)
            c = self.ws.cell(row=row, column=1, value=label)
            c.font, c.alignment = self.bold_font, self.right_align
            self.ws.cell(row=row, column=1).border = Border(left=self.thick, top=self.thin, bottom=self.thin)
            self.ws.cell(row=row, column=2).border = Border(right=self.thick, top=self.thin, bottom=self.thin)

        shifts_by_user = {}
        for s in shifts: shifts_by_user.setdefault(s.user_id, []).append(s)

        for emp in employees:
            start_col = emp_col_start.get(emp.id)
            user_shifts = shifts_by_user.get(emp.id, [])
            total_worked = holiday_hours = saturday_hours = sunday_hours = night_hours = 0.0
            transferred = float(emp.initial_hours_balance or 0.0)
            
            for s in user_shifts:
                duration = float(s.type_shift.duration_time) if s.type_shift and s.type_shift.duration_time else self._get_shift_duration(s.custom_start, s.custom_end)
                total_worked += duration
                if s.type_shift.id in self.NON_WORKING_IDS or not (s.custom_start and s.custom_end): continue
                
                dt_s = datetime.combine(s.date, s.custom_start)
                dt_e = datetime.combine(s.date, s.custom_end)
                if dt_e < dt_s: dt_e += timedelta(days=1)
                
                curr = dt_s
                while curr < dt_e:
                    seg_end = min(dt_e, datetime.combine(curr.date() + timedelta(days=1), time(0,0)))
                    seg_duration = (seg_end - curr).total_seconds() / 3600.0
                    if curr.weekday() == 5: saturday_hours += seg_duration
                    elif curr.weekday() == 6: sunday_hours += seg_duration
                    if curr.date() in holidays_dates: holiday_hours += seg_duration
                    curr = seg_end
                
                check_d, final_d = dt_s.date() - timedelta(days=1), dt_e.date()
                while check_d <= final_d:
                    night_hours += self._calculate_overlap_seconds(dt_s, dt_e, datetime.combine(check_d, time(22, 0)), datetime.combine(check_d + timedelta(days=1), time(6, 0))) / 3600.0
                    check_d += timedelta(days=1)

            diff = total_worked - work_fund
            vals = [transferred, total_worked, diff, transferred + diff, holiday_hours, saturday_hours, sunday_hours, night_hours]
            for i, v in enumerate(vals):
                row = SUMMARY_START_ROW + i
                self.ws.merge_cells(start_row=row, start_column=start_col, end_row=row, end_column=start_col + 5)
                c = self.ws.cell(row=row, column=start_col, value=round(v, 2))
                c.alignment, c.font = self.center_align, Font(bold=(i==3))
                for k in range(6):
                    bc = self.ws.cell(row=row, column=start_col + k)
                    bc.border = Border(left=(self.thick if k==0 else self.thin), right=(self.thick if k==5 else self.thin), top=self.thin, bottom=self.thin)

        # 7. DYNAMICKÁ LEGENDA
        categories = [
            {"title": "sobota, nedeľa", "ids": [8, 9, 10, 11, 12]},
            {"title": "Dopoludnia", "ids": [13, 14, 15]},
            {"title": "Popoludní", "ids": [17, 18, 19]},
            {"title": "Nočná služba", "ids": [20]},
            {"title": "iná činnosť", "ids": [22]}
        ]

        LEGEND_START_ROW, curr_legend_col = SUMMARY_START_ROW + len(labels) + 2, 1
        BLOCK_WIDTH = 4

        for cat in categories:
            items = []
            for ts in TypeShift.objects.filter(id__in=cat["ids"]):
                h = str(ts.duration_time) if ts.duration_time else ""
                t_range = f"{ts.start_time.strftime('%H,%M')}-{ts.end_time.strftime('%H,%M')}" if ts.start_time and ts.end_time else ""
                if [h, t_range] not in items: items.append([h, t_range])
            
            # Nadpis
            self.ws.merge_cells(start_row=LEGEND_START_ROW, start_column=curr_legend_col, end_row=LEGEND_START_ROW, end_column=curr_legend_col + BLOCK_WIDTH - 1)
            tc = self.ws.cell(row=LEGEND_START_ROW, column=curr_legend_col, value=cat["title"])
            tc.font, tc.alignment = self.bold_font, self.center_align
            self.ws.cell(row=LEGEND_START_ROW, column=curr_legend_col).border = Border(top=self.thick, left=self.thick, bottom=self.thin)
            self.ws.cell(row=LEGEND_START_ROW, column=curr_legend_col + BLOCK_WIDTH - 1).border = Border(top=self.thick, right=self.thick, bottom=self.thin)
            for k in range(1, BLOCK_WIDTH - 1): self.ws.cell(row=LEGEND_START_ROW, column=curr_legend_col + k).border = Border(top=self.thick, bottom=self.thin)

            # Podnadpisy
            c_lbl_h = self.ws.cell(row=LEGEND_START_ROW + 1, column=curr_legend_col, value="hodiny")
            c_lbl_h.font, c_lbl_h.alignment = Font(size=8, bold=True), self.center_align
            c_lbl_h.border = Border(left=self.thick, right=self.thin, top=self.thin, bottom=self.thin)

            self.ws.merge_cells(start_row=LEGEND_START_ROW + 1, start_column=curr_legend_col + 1, end_row=LEGEND_START_ROW + 1, end_column=curr_legend_col + BLOCK_WIDTH - 1)
            c_lbl_t = self.ws.cell(row=LEGEND_START_ROW + 1, column=curr_legend_col + 1, value="v čase")
            c_lbl_t.font, c_lbl_t.alignment = Font(size=8, bold=True), self.center_align
            c_lbl_t.border = Border(left=self.thin, top=self.thin, bottom=self.thin)
            self.ws.cell(row=LEGEND_START_ROW + 1, column=curr_legend_col + BLOCK_WIDTH - 1).border = Border(right=self.thick, top=self.thin, bottom=self.thin)

            # Dáta
            for i in range(4):
                row_idx = LEGEND_START_ROW + 2 + i
                val_h, val_t = items[i] if i < len(items) else ("", "")
                
                ch = self.ws.cell(row=row_idx, column=curr_legend_col, value=val_h)
                ch.alignment = self.center_align
                
                self.ws.merge_cells(start_row=row_idx, start_column=curr_legend_col + 1, end_row=row_idx, end_column=curr_legend_col + BLOCK_WIDTH - 1)
                ct = self.ws.cell(row=row_idx, column=curr_legend_col + 1, value=val_t)
                ct.alignment = self.center_align

                b_bottom = self.thick if i == 3 else self.thin
                ch.border = Border(left=self.thick, right=self.thin, top=self.thin, bottom=b_bottom)
                ct.border = Border(left=self.thin, top=self.thin, bottom=b_bottom)
                self.ws.cell(row=row_idx, column=curr_legend_col + BLOCK_WIDTH - 1).border = Border(right=self.thick, top=self.thin, bottom=b_bottom)
                for k in range(2, BLOCK_WIDTH - 1): self.ws.cell(row=row_idx, column=curr_legend_col + k).border = Border(top=self.thin, bottom=b_bottom)

            curr_legend_col += BLOCK_WIDTH

        # 8. Uloženie a Response
        response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
        response['Content-Disposition'] = f'attachment; filename=Rozpis_FULL_{self.month}_{self.year}.xlsx'
        self.wb.save(response)
        return response
    




# class AttendancePdfExporter:
#     def __init__(self, employee_id, year, month):
#         self.employee_id = employee_id
#         self.year = year
#         self.month = month
        
#         # Ošetrenie, ak zamestnanec neexistuje
#         try:
#             self.employee = Employees.objects.get(pk=employee_id)
#         except Employees.DoesNotExist:
#              self.employee = None

#         # --- REGISTRÁCIA FONTU (Arial) ---
#         # Skúsime nájsť Arial vo Windows priečinku fontov
#         # Ak nie sme na Windowse alebo font neexistuje, použijeme defaultnú Helveticu
        
#         self.custom_font = 'Helvetica'
#         self.custom_font_bold = 'Helvetica-Bold'
        
#         try:
#             # Cesta k fontom vo Windows
#             fonts_dir = os.path.join(os.environ.get('WINDIR', 'C:\\Windows'), 'Fonts')
#             arial_path = os.path.join(fonts_dir, 'arial.ttf')
#             arialbd_path = os.path.join(fonts_dir, 'arialbd.ttf')
            
#             # Overenie existencie súborov
#             if os.path.exists(arial_path) and os.path.exists(arialbd_path):
#                 # Registrácia fontov pod vlastnými názvami
#                 pdfmetrics.registerFont(TTFont('ArialCustom', arial_path))
#                 pdfmetrics.registerFont(TTFont('ArialBoldCustom', arialbd_path))
                
#                 # Nastavenie premenných na použitie nových fontov
#                 self.custom_font = 'ArialCustom'
#                 self.custom_font_bold = 'ArialBoldCustom'
#         except Exception:
#             # V prípade akejkoľvek chyby pri registrácii fontu ostaneme pri Helvetice
#             pass
        
#         # Nastavenie štýlov
#         self.styles = getSampleStyleSheet()
#         # Vytvoríme vlastný štýl pre normálny text s našim fontom
#         self.styles.add(ParagraphStyle(name='CustomNormal', parent=self.styles['Normal'], fontName=self.custom_font, fontSize=10))
#         # Vytvoríme vlastný štýl pre nadpis s našim tučným fontom
#         self.styles.add(ParagraphStyle(name='CustomTitle', parent=self.styles['Title'], fontName=self.custom_font_bold))
        
#         self.buffer = BytesIO()
#         self.doc = SimpleDocTemplate(
#             self.buffer, 
#             pagesize=landscape(A4),
#             rightMargin=10*mm, leftMargin=10*mm, 
#             topMargin=10*mm, bottomMargin=10*mm
#         )
#         self.elements = []
#         self.notes_list = [] # Inicializácia zoznamu poznámok

#     def _format_time(self, t):
#         if not t: return ""
#         return t.strftime("%H,%M")

#     def _format_duration(self, seconds):
#         if not seconds: return ""
#         hours = seconds / 3600.0
#         if hours % 1 == 0:
#             return f"{int(hours)}"
#         return f"{hours:.1f}".replace(".", ",")

#     def generate_response(self):
#         # 1. Zber Dát
#         days_in_month = monthrange(self.year, self.month)[1]
#         start_date = date(self.year, self.month, 1)
#         end_date = date(self.year, self.month, days_in_month)
        
#         attendances = Attendance.objects.filter(
#             user_id=self.employee_id,
#             date__range=(start_date, end_date)
#         ).select_related('type_shift').order_by('date')
        
#         att_by_date = {a.date: a for a in attendances}
#         holidays = set(val[0] for val in CalendarDay.get_slovak_holidays(self.year))

#         slovak_months = ["", "Január", "Február", "Marec", "Apríl", "Máj", "Jún", 
#                          "Júl", "August", "September", "Október", "November", "December"]

#         # 2. Hlavička dokumentu (Texty)
#         header_text = f"<b>Centrum pre deti a rodiny Poprad</b><br/>Výkaz pedagogických pracovníkov, pomocných vychovávateľov a ostatných pracovníkov za"
#         self.elements.append(Paragraph(header_text, self.styles['CustomTitle']))
#         self.elements.append(Spacer(1, 5*mm))

#         info_data = [
#             [f"Mesiac / Rok: {slovak_months[self.month]} {self.year}", 
#              f"Meno: {self.employee.last_name} {self.employee.first_name}" if self.employee else "", 
#              f"Osobné číslo: {self.employee.personal_number or ''}" if self.employee else ""]
#         ]
#         info_table = Table(info_data, colWidths=[80*mm, 120*mm, 60*mm])
#         info_table.setStyle(TableStyle([
#             ('FONTNAME', (0,0), (-1,-1), self.custom_font_bold), 
#             ('FONTSIZE', (0,0), (-1,-1), 10),
#             ('ALIGN', (0,0), (-1,-1), 'LEFT'),
#         ]))
#         self.elements.append(info_table)
#         self.elements.append(Spacer(1, 5*mm))

#         # 3. TABUĽKA - HLAVIČKA
#         table_data = []
        
#         # Prvý riadok hlavičky (Skupiny)
#         headers_row1 = [
#             "",              # Nad "Deň" (0)
#             "Dopoludnia",    # (1)
#             "",              # (2) - zlúčené s 1
#             "Odpoludnia",    # (3)
#             "",              # (4) - zlúčené s 3
#             "",              # Nad "Odp.hod." (5)
#             "Príplatky",     # (6)
#             "",              # (7) - zlúčené s 6
#             "",              # (8) - zlúčené s 6
#             "",              # (9) - zlúčené s 6
#             "",              # (10) - zlúčené s 6
#             "Neodpr. hod.",  # (11)
#             ""               # (12) - zlúčené s 11
#         ]
        
#         # Druhý riadok hlavičky (Konkrétne stĺpce)
#         headers_row2 = [
#             "Deň",           # 0
#             "Príchod",       # 1  (Dopoludnia)
#             "Odchod",        # 2  (Dopoludnia)
#             "Príchod",       # 3  (Odpoludnia)
#             "Odchod",        # 4  (Odpoludnia)
#             "Odp.hod.",      # 5
#             "Sob.",          # 6
#             "Ned.",          # 7
#             "Iná\nčinn.",    # 8
#             "Sviatok",       # 9
#             "Nočná",         # 10
#             "Dovol.",        # 11
#             "PN"             # 12
#         ]
        
#         table_data.append(headers_row1)
#         table_data.append(headers_row2)

#         total_worked = 0.0
#         sum_sob, sum_ned, sum_ina, sum_sviatok, sum_noc, sum_dov, sum_pn = 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0
        
#         # 4. Riadky dní
#         for day in range(1, days_in_month + 1):
#             curr_date = date(self.year, self.month, day)
#             att = att_by_date.get(curr_date)
#             row = [f"{day}."] + [""] * 12
            
#             if att:
#                 s_time = att.custom_start
#                 e_time = att.custom_end
#                 duration = 0.0
                
#                 # Výpočet trvania
#                 if att.type_shift and att.type_shift.duration_time:
#                      duration = float(att.type_shift.duration_time)
#                 elif s_time and e_time:
#                     dt_s = datetime.combine(curr_date, s_time)
#                     dt_e = datetime.combine(curr_date, e_time)
#                     if dt_e < dt_s: dt_e += timedelta(days=1)
#                     if e_time == time(0,0) and s_time != e_time: dt_e += timedelta(days=1)
#                     duration = (dt_e - dt_s).total_seconds() / 3600.0

#                 # --- HLAVNÁ ZMENA LOGIKY ---
#                 # Zápis časov: Dopoludnia vs Odpoludnia
#                 # index 1, 2 = Dopoludnia
#                 # index 3, 4 = Odpoludnia
                
#                 # Definujeme ID pre absencie, pri ktorých nepíšeme časy
#                 ABSENCE_IDS = [21, 23] 

#                 if att.type_shift and att.type_shift.id not in ABSENCE_IDS:
#                     if s_time and e_time:
#                         NOON = time(12, 0)
                        
#                         # 1. ZÁPIS PRÍCHODU (Start)
#                         # Ak začína pred 12:00 -> Dopoludnia (idx 1), inak Odpoludnia (idx 3)
#                         if s_time < NOON:
#                             row[1] = self._format_time(s_time)
#                         else:
#                             row[3] = self._format_time(s_time)

#                         # 2. ZÁPIS ODCHODU (End)
#                         # Logika: 
#                         # - Ak smena prechádza cez polnoc (e_time < s_time), končí určite "poobede/ráno ďalšieho dňa" -> Dávame do Odpoludnia (idx 4)
#                         # - Ak končí po 12:00 -> Odpoludnia (idx 4)
#                         # - Ak končí pred 12:00 -> Dopoludnia (idx 2)
                        
#                         is_overnight = e_time < s_time # Nočná smena
                        
#                         if is_overnight or e_time >= NOON:
#                             row[4] = self._format_time(e_time) # Odchod Odpoludnia
#                         else:
#                             row[2] = self._format_time(e_time) # Odchod Dopoludnia

#                     # Zápis odpracovaných hodín
#                     if duration > 0:
#                         row[5] = self._format_duration(duration * 3600)
#                         total_worked += duration

#                 # --- PRÍPLATKY (Stĺpce 6-12) ---
#                 if curr_date.weekday() == 5: # Sobota
#                     row[6] = self._format_duration(duration * 3600)
#                     sum_sob += duration
#                 elif curr_date.weekday() == 6: # Nedeľa
#                     row[7] = self._format_duration(duration * 3600)
#                     sum_ned += duration
                
#                 if att.type_shift and att.type_shift.id == 22: # Iná činnosť
#                     row[8] = self._format_duration(duration * 3600)
#                     sum_ina += duration
                
#                 if curr_date in holidays and att.type_shift.id not in ABSENCE_IDS: # Sviatok
#                      row[9] = self._format_duration(duration * 3600)
#                      sum_sviatok += duration

#                 if att.type_shift and att.type_shift.id == 20: # Nočná
#                      row[10] = self._format_duration(duration * 3600)
#                      sum_noc += duration
                
#                 if att.type_shift and att.type_shift.id == 21: # Dovolenka
#                     row[11] = "D"
#                     sum_dov += 7.5 
                
#                 if att.type_shift and att.type_shift.id == 23: # PN
#                     row[12] = "PN"
#                     sum_pn += 7.5
                
#                 if att.note:
#                     self.notes_list.append(f"{day}. {self.month}. - {att.note}")

#             table_data.append(row)

#         # Riadok Spolu
#         row_total = ["Spolu", "", "", "", "", 
#                      self._format_duration(total_worked * 3600),
#                      self._format_duration(sum_sob * 3600),
#                      self._format_duration(sum_ned * 3600),
#                      self._format_duration(sum_ina * 3600),
#                      self._format_duration(sum_sviatok * 3600),
#                      self._format_duration(sum_noc * 3600),
#                      self._format_duration(sum_dov * 3600) if sum_dov else "",
#                      self._format_duration(sum_pn * 3600) if sum_pn else ""]
#         table_data.append(row_total)

#         # Vykreslenie Tabuľky
#         col_widths = [10*mm] + [18*mm]*4 + [15*mm]*8
#         t = Table(table_data, colWidths=col_widths, repeatRows=2)
        
#         # Štýlovanie tabuľky
#         t.setStyle(TableStyle([
#             ('GRID', (0,0), (-1,-1), 0.5, colors.black),
#             ('FONTNAME', (0,0), (-1,-1), self.custom_font),
#             ('FONTSIZE', (0,0), (-1,-1), 8),
#             ('ALIGN', (0,0), (-1,-1), 'CENTER'),
#             ('VALIGN', (0,0), (-1,-1), 'MIDDLE'),
            
#             # Zlúčenie buniek pre hlavičku
#             ('SPAN', (1,0), (2,0)),   # Dopoludnia
#             ('SPAN', (3,0), (4,0)),   # Odpoludnia
#             ('SPAN', (6,0), (10,0)),  # Príplatky
#             ('SPAN', (11,0), (12,0)), # Neodpr. hod.
            
#             # Fonty pre hlavičku
#             ('FONTNAME', (0,0), (-1,1), self.custom_font_bold),
            
#             # Spolu riadok
#             ('FONTNAME', (0,-1), (-1,-1), self.custom_font_bold),
#             ('BACKGROUND', (0,-1), (-1,-1), colors.lightgrey),
#         ]))
        
#         self.elements.append(t)
#         self.elements.append(Spacer(1, 5*mm))

#         # Poznámky
#         if self.notes_list:
#              notes_text = "Poznámky: " + "; ".join(self.notes_list)
#              self.elements.append(Paragraph(notes_text, self.styles['CustomNormal']))
#              self.elements.append(Spacer(1, 5*mm))

#         # Pätička
#         transferred = float(self.employee.initial_hours_balance or 0.0) if self.employee else 0.0
#         work_days_count = sum(1 for d in range(1, days_in_month + 1) if date(self.year, self.month, d).weekday() < 5)
#         fund = work_days_count * 7.5
        
#         balance = total_worked - fund
#         final = transferred + balance

#         footer_data = [
#             ["Prenesené hodiny", "FPČ", "Odpracované hod.\ncelkom +D+PN+P", "+ / - za mesiac", "Konečný stav\nhod. + -"],
#             [f"{transferred:+.1f}", f"{fund}", f"{total_worked:.1f}", f"{balance:+.1f}", f"{final:+.1f}"]
#         ]
        
#         footer_table = Table(footer_data, colWidths=[30*mm]*5)
#         footer_table.setStyle(TableStyle([
#             ('GRID', (0,0), (-1,-1), 0.5, colors.black),
#             ('ALIGN', (0,0), (-1,-1), 'CENTER'),
#             ('FONTNAME', (0,0), (-1,-1), self.custom_font_bold),
#         ]))
#         self.elements.append(footer_table)
#         self.elements.append(Spacer(1, 15*mm))
        
#         # Podpisy
#         signatures = [["Vyhotovil: ........................", "Kontroloval: ........................", "Schválil: ........................"]]
#         sig_table = Table(signatures, colWidths=[90*mm, 90*mm, 90*mm])
#         sig_table.setStyle(TableStyle([
#             ('ALIGN', (0,0), (-1,-1), 'LEFT'),
#             ('FONTNAME', (0,0), (-1,-1), self.custom_font),
#         ]))
#         self.elements.append(sig_table)

#         self.doc.build(self.elements)
        
#         pdf = self.buffer.getvalue()
#         self.buffer.close()
        
#         response = HttpResponse(content_type='application/pdf')
#         filename = f"Vykaz_{self.employee.last_name}_{self.month}_{self.year}.pdf" if self.employee else "Vykaz.pdf"
#         response['Content-Disposition'] = f'attachment; filename="{filename}"'
#         response.write(pdf)
#         return response


class AttendancePdfExporter:
    def __init__(self, employee_id, year, month):
        self.employee_id = employee_id
        self.year = year
        self.month = month
        
        # Ošetrenie, ak zamestnanec neexistuje
        try:
            self.employee = Employees.objects.get(pk=employee_id)
        except Employees.DoesNotExist:
             self.employee = None

        # --- REGISTRÁCIA FONTU (Arial) ---
        self.custom_font = 'Helvetica'
        self.custom_font_bold = 'Helvetica-Bold'
        
        try:
            fonts_dir = os.path.join(os.environ.get('WINDIR', 'C:\\Windows'), 'Fonts')
            arial_path = os.path.join(fonts_dir, 'arial.ttf')
            arialbd_path = os.path.join(fonts_dir, 'arialbd.ttf')
            
            if os.path.exists(arial_path) and os.path.exists(arialbd_path):
                pdfmetrics.registerFont(TTFont('ArialCustom', arial_path))
                pdfmetrics.registerFont(TTFont('ArialBoldCustom', arialbd_path))
                self.custom_font = 'ArialCustom'
                self.custom_font_bold = 'ArialBoldCustom'
        except Exception:
            pass
        
        # Nastavenie štýlov
        self.styles = getSampleStyleSheet()
        self.styles.add(ParagraphStyle(name='CustomNormal', parent=self.styles['Normal'], fontName=self.custom_font, fontSize=10))
        self.styles.add(ParagraphStyle(name='CustomTitle', parent=self.styles['Title'], fontName=self.custom_font_bold, alignment=1)) # 1=Center
        
        self.buffer = BytesIO()
        
        # --- ZMENA NA PORTRAIT (VÝŠKA) ---
        self.doc = SimpleDocTemplate(
            self.buffer, 
            pagesize=A4,  # <-- Tu je zmena (bez landscape)
            rightMargin=10*mm, leftMargin=10*mm, 
            topMargin=10*mm, bottomMargin=10*mm
        )
        self.elements = []
        self.notes_list = []

    def _format_time(self, t):
        if not t: return ""
        return t.strftime("%H,%M")

    def _format_duration(self, seconds):
        if not seconds: return ""
        hours = seconds / 3600.0
        if hours % 1 == 0:
            return f"{int(hours)}"
        return f"{hours:.1f}".replace(".", ",")

    def generate_response(self):
        # 1. Zber Dát
        days_in_month = monthrange(self.year, self.month)[1]
        start_date = date(self.year, self.month, 1)
        end_date = date(self.year, self.month, days_in_month)
        
        attendances = Attendance.objects.filter(
            user_id=self.employee_id,
            date__range=(start_date, end_date)
        ).select_related('type_shift').order_by('date')
        
        att_by_date = {a.date: a for a in attendances}
        holidays = set(val[0] for val in CalendarDay.get_slovak_holidays(self.year))

        slovak_months = ["", "Január", "Február", "Marec", "Apríl", "Máj", "Jún", 
                         "Júl", "August", "September", "Október", "November", "December"]

        # 2. Hlavička dokumentu
        header_text = f"<b>Centrum pre deti a rodiny Poprad</b><br/>Výkaz pedagogických pracovníkov, pomocných vychovávateľov a ostatných pracovníkov za"
        self.elements.append(Paragraph(header_text, self.styles['CustomTitle']))
        self.elements.append(Spacer(1, 5*mm))

        # Úprava šírky tabuľky s info (aby sa zmestila na A4 Portrait)
        # Celková šírka cca 190mm
        info_data = [
            [f"Mesiac / Rok: {slovak_months[self.month]} {self.year}", 
             f"Meno: {self.employee.last_name} {self.employee.first_name}" if self.employee else "", 
             f"Os.č.: {self.employee.personal_number or ''}" if self.employee else ""]
        ]
        info_table = Table(info_data, colWidths=[50*mm, 90*mm, 50*mm])
        info_table.setStyle(TableStyle([
            ('FONTNAME', (0,0), (-1,-1), self.custom_font_bold), 
            ('FONTSIZE', (0,0), (-1,-1), 10),
            ('ALIGN', (0,0), (-1,-1), 'LEFT'),
        ]))
        self.elements.append(info_table)
        self.elements.append(Spacer(1, 5*mm))

        # 3. TABUĽKA - HLAVIČKA
        table_data = []
        
        headers_row1 = ["", "Dopoludnia", "", "Odpoludnia", "", "", "Príplatky", "", "", "", "", "Neodpr. hod.", ""]
        headers_row2 = ["Deň", "Príchod", "Odchod", "Príchod", "Odchod", "Odp.hod.", "Sob.", "Ned.", "Iná\nčinn.", "Sviatok", "Nočná", "Dovol.", "PN"]
        
        table_data.append(headers_row1)
        table_data.append(headers_row2)

        total_worked = 0.0
        sum_sob, sum_ned, sum_ina, sum_sviatok, sum_noc, sum_dov, sum_pn = 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0
        
        # 4. Riadky dní
        for day in range(1, days_in_month + 1):
            curr_date = date(self.year, self.month, day)
            att = att_by_date.get(curr_date)
            row = [f"{day}."] + [""] * 12
            
            if att:
                s_time = att.custom_start
                e_time = att.custom_end
                duration = 0.0
                
                if att.type_shift and att.type_shift.duration_time:
                     duration = float(att.type_shift.duration_time)
                elif s_time and e_time:
                    dt_s = datetime.combine(curr_date, s_time)
                    dt_e = datetime.combine(curr_date, e_time)
                    if dt_e < dt_s: dt_e += timedelta(days=1)
                    if e_time == time(0,0) and s_time != e_time: dt_e += timedelta(days=1)
                    duration = (dt_e - dt_s).total_seconds() / 3600.0

                ABSENCE_IDS = [21, 23] 

                if att.type_shift and att.type_shift.id not in ABSENCE_IDS:
                    if s_time and e_time:
                        NOON = time(12, 0)
                        if s_time < NOON:
                            row[1] = self._format_time(s_time)
                        else:
                            row[3] = self._format_time(s_time)

                        is_overnight = e_time < s_time
                        if is_overnight or e_time >= NOON:
                            row[4] = self._format_time(e_time)
                        else:
                            row[2] = self._format_time(e_time)

                    if duration > 0:
                        row[5] = self._format_duration(duration * 3600)
                        total_worked += duration

                if curr_date.weekday() == 5: 
                    row[6] = self._format_duration(duration * 3600)
                    sum_sob += duration
                elif curr_date.weekday() == 6: 
                    row[7] = self._format_duration(duration * 3600)
                    sum_ned += duration
                
                if att.type_shift and att.type_shift.id == 22:
                    row[8] = self._format_duration(duration * 3600)
                    sum_ina += duration
                
                if curr_date in holidays and att.type_shift.id not in ABSENCE_IDS:
                     row[9] = self._format_duration(duration * 3600)
                     sum_sviatok += duration

                if att.type_shift and att.type_shift.id == 20:
                     row[10] = self._format_duration(duration * 3600)
                     sum_noc += duration
                
                if att.type_shift and att.type_shift.id == 21:
                    row[11] = "D"
                    sum_dov += 7.5 
                
                if att.type_shift and att.type_shift.id == 23:
                    row[12] = "PN"
                    sum_pn += 7.5
                
                if att.note:
                    self.notes_list.append(f"{day}. {self.month}. - {att.note}")

            table_data.append(row)

        row_total = ["Spolu", "", "", "", "", 
                     self._format_duration(total_worked * 3600),
                     self._format_duration(sum_sob * 3600),
                     self._format_duration(sum_ned * 3600),
                     self._format_duration(sum_ina * 3600),
                     self._format_duration(sum_sviatok * 3600),
                     self._format_duration(sum_noc * 3600),
                     self._format_duration(sum_dov * 3600) if sum_dov else "",
                     self._format_duration(sum_pn * 3600) if sum_pn else ""]
        table_data.append(row_total)

        # --- NOVÉ ŠÍRKY STĹPCOV PRE PORTRAIT (VÝŠKA) ---
        # Celková šírka A4 = 210mm, okraje = 20mm, zostáva 190mm
        # Rozdelenie: 
        # Deň: 10mm
        # Časy (4 stĺpce): 16mm * 4 = 64mm
        # Zvyšné (8 stĺpcov): 13mm * 8 = 104mm
        # Spolu: 10 + 64 + 104 = 178mm (zmestí sa do 190mm)
        col_widths = [10*mm] + [16*mm]*4 + [13*mm]*8
        
        t = Table(table_data, colWidths=col_widths, repeatRows=2)
        
        t.setStyle(TableStyle([
            ('GRID', (0,0), (-1,-1), 0.5, colors.black),
            ('FONTNAME', (0,0), (-1,-1), self.custom_font),
            ('FONTSIZE', (0,0), (-1,-1), 8),
            ('ALIGN', (0,0), (-1,-1), 'CENTER'),
            ('VALIGN', (0,0), (-1,-1), 'MIDDLE'),
            
            ('SPAN', (1,0), (2,0)),
            ('SPAN', (3,0), (4,0)),
            ('SPAN', (6,0), (10,0)),
            ('SPAN', (11,0), (12,0)),
            
            ('FONTNAME', (0,0), (-1,1), self.custom_font_bold),
            ('FONTNAME', (0,-1), (-1,-1), self.custom_font_bold),
            ('BACKGROUND', (0,-1), (-1,-1), colors.lightgrey),
        ]))
        
        self.elements.append(t)
        self.elements.append(Spacer(1, 5*mm))

        if self.notes_list:
             notes_text = "Poznámky: " + "; ".join(self.notes_list)
             self.elements.append(Paragraph(notes_text, self.styles['CustomNormal']))
             self.elements.append(Spacer(1, 5*mm))

        transferred = float(self.employee.initial_hours_balance or 0.0) if self.employee else 0.0
        work_days_count = sum(1 for d in range(1, days_in_month + 1) if date(self.year, self.month, d).weekday() < 5)
        fund = work_days_count * 7.5
        balance = total_worked - fund
        final = transferred + balance

        footer_data = [
            ["Prenesené hodiny", "FPČ", "Odpracované hod.\ncelkom +D+PN+P", "+ / - za mesiac", "Konečný stav\nhod. + -"],
            [f"{transferred:+.1f}", f"{fund}", f"{total_worked:.1f}", f"{balance:+.1f}", f"{final:+.1f}"]
        ]
        
        # Úprava šírky pätičky pre Portrait
        footer_table = Table(footer_data, colWidths=[38*mm]*5)
        footer_table.setStyle(TableStyle([
            ('GRID', (0,0), (-1,-1), 0.5, colors.black),
            ('ALIGN', (0,0), (-1,-1), 'CENTER'),
            ('FONTNAME', (0,0), (-1,-1), self.custom_font_bold),
            ('FONTSIZE', (0,0), (-1,-1), 8),
        ]))
        self.elements.append(footer_table)
        self.elements.append(Spacer(1, 15*mm))
        
        # Úprava šírky podpisov pre Portrait
        signatures = [["Vyhotovil: ........................", "Kontroloval: ........................", "Schválil: ........................"]]
        sig_table = Table(signatures, colWidths=[63*mm, 63*mm, 63*mm])
        sig_table.setStyle(TableStyle([
            ('ALIGN', (0,0), (-1,-1), 'LEFT'),
            ('FONTNAME', (0,0), (-1,-1), self.custom_font),
            ('FONTSIZE', (0,0), (-1,-1), 9),
        ]))
        self.elements.append(sig_table)

        self.doc.build(self.elements)
        
        pdf = self.buffer.getvalue()
        self.buffer.close()
        
        response = HttpResponse(content_type='application/pdf')
        filename = f"Vykaz_{self.employee.last_name}_{self.month}_{self.year}.pdf" if self.employee else "Vykaz.pdf"
        response['Content-Disposition'] = f'attachment; filename="{filename}"'
        response.write(pdf)
        return response


from reportlab.lib import colors
from reportlab.lib.pagesizes import A5, landscape
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, PageBreak
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import mm
from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_RIGHT
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from io import BytesIO
from datetime import date, timedelta
from calendar import monthrange
import os
from django.http import HttpResponse

# Importy modelov
from .models import PlannedShifts, Employees, CalendarDay

class VacationFormExporter:
    def __init__(self, employee_id, year, month):
        self.employee_id = employee_id
        self.year = year
        self.month = month
        
        # Načítanie zamestnanca
        try:
            self.employee = Employees.objects.get(pk=employee_id)
        except Employees.DoesNotExist:
             self.employee = None

        # --- REGISTRÁCIA FONTOV ---
        self.custom_font = 'Helvetica'
        self.custom_font_bold = 'Helvetica-Bold'
        
        try:
            fonts_dir = os.path.join(os.environ.get('WINDIR', 'C:\\Windows'), 'Fonts')
            arial_path = os.path.join(fonts_dir, 'arial.ttf')
            arialbd_path = os.path.join(fonts_dir, 'arialbd.ttf')
            
            if os.path.exists(arial_path) and os.path.exists(arialbd_path):
                pdfmetrics.registerFont(TTFont('ArialCustom', arial_path))
                pdfmetrics.registerFont(TTFont('ArialBoldCustom', arialbd_path))
                self.custom_font = 'ArialCustom'
                self.custom_font_bold = 'ArialBoldCustom'
        except Exception:
            pass
        
        # Nastavenie štýlov
        self.styles = getSampleStyleSheet()
        self.styles.add(ParagraphStyle(name='VacationTitle', parent=self.styles['Normal'], fontName=self.custom_font_bold, fontSize=14, alignment=TA_CENTER, spaceAfter=2*mm))
        self.styles.add(ParagraphStyle(name='VacationText', parent=self.styles['Normal'], fontName=self.custom_font, fontSize=10))
        self.styles.add(ParagraphStyle(name='VacationLabel', parent=self.styles['Normal'], fontName=self.custom_font, fontSize=7, textColor=colors.black))

        self.buffer = BytesIO()
        
        # A5 Landscape
        self.doc = SimpleDocTemplate(
            self.buffer, 
            pagesize=landscape(A5),
            rightMargin=10*mm, leftMargin=10*mm, 
            topMargin=10*mm, bottomMargin=10*mm
        )
        self.elements = []

    def _draw_border(self, canvas, doc):
        """Vykreslí rámček okolo celej strany"""
        canvas.saveState()
        canvas.setStrokeColor(colors.black)
        canvas.setLineWidth(2)
        width, height = landscape(A5)
        margin = 5*mm
        canvas.rect(margin, margin, width - 2*margin, height - 2*margin)
        canvas.restoreState()

    def _get_working_days_count(self, start_date, end_date):
        count = 0
        curr = start_date
        holidays = set(val[0] for val in CalendarDay.get_slovak_holidays(self.year))
        while curr <= end_date:
            if curr.weekday() < 5 and curr not in holidays:
                count += 1
            curr += timedelta(days=1)
        return count

    def _group_consecutive_dates(self, shifts):
        if not shifts: return []
        groups = []
        current_group = [shifts[0]]
        for i in range(1, len(shifts)):
            prev_date = shifts[i-1].date
            curr_date = shifts[i].date
            if curr_date == prev_date + timedelta(days=1):
                current_group.append(shifts[i])
            else:
                groups.append(current_group)
                current_group = [shifts[i]]
        if current_group: groups.append(current_group)
        return groups

    def _draw_form(self, group):
        start_date = group[0].date
        end_date = group[-1].date
        work_days = self._get_working_days_count(start_date, end_date)
        
        # --- 1. NADPIS ---
        self.elements.append(Paragraph("DOVOLENKA", self.styles['VacationTitle']))
        self.elements.append(Spacer(1, 2*mm))

        # --- 2. HLAVNÝ RÁMEC S ÚDAJMI ---
        emp_name = f"{self.employee.last_name} {self.employee.first_name}" if self.employee else ""
        emp_num = f"{self.employee.personal_number}" if self.employee else ""
        
        # Riadok 1: Meno a Osobné číslo
        data_top = [
            [Paragraph("Priezvisko, meno, titul", self.styles['VacationLabel']), Paragraph("Osobné číslo", self.styles['VacationLabel'])],
            [Paragraph(f"{emp_name}", self.styles['VacationText']), Paragraph(f"{emp_num}", self.styles['VacationText'])]
        ]
        t_top = Table(data_top, colWidths=[130*mm, 50*mm])
        t_top.setStyle(TableStyle([
            ('LINEBELOW', (0,1), (-1,1), 1, colors.black),
            ('VALIGN', (0,0), (-1,-1), 'TOP'),
            ('LEFTPADDING', (0,0), (-1,-1), 0),
        ]))
        self.elements.append(t_top)
        
        # Riadok 2: Útvar
        data_dept = [
            [
                Paragraph("Útvar: Centrum pre deti a rodiny Poprad, Pavlovova 4375/", self.styles['VacationText']),
                Paragraph("Číslo útvaru ...........", self.styles['VacationText'])
            ]
        ]
        t_dept = Table(data_dept, colWidths=[130*mm, 50*mm])
        t_dept.setStyle(TableStyle([
            ('LINEBELOW', (0,0), (-1,-1), 1, colors.black),
            ('LEFTPADDING', (0,0), (-1,-1), 0),
            ('ALIGN', (1,0), (1,0), 'RIGHT'),
            ('VALIGN', (0,0), (-1,-1), 'BOTTOM'),
        ]))
        self.elements.append(t_dept)
        
        self.elements.append(Spacer(1, 5*mm))

        # --- 3. DÁTUMY ---
        self.elements.append(Paragraph(f"Žiada o dovolenku na zotavenie za kalendárny rok {self.year}", self.styles['VacationText']))
        self.elements.append(Spacer(1, 3*mm))
        
        s_str = start_date.strftime("%d. %m. %Y")
        e_str = end_date.strftime("%d. %m. %Y")
        
        data_dates = [
            [f"od  {s_str}", f"do  {e_str}", f"vrátane, t.j.  {work_days}  pracovných dní"]
        ]
        t_dates = Table(data_dates, colWidths=[50*mm, 50*mm, 80*mm])
        t_dates.setStyle(TableStyle([
            ('ALIGN', (0,0), (-1,-1), 'LEFT'),
            ('FONTNAME', (0,0), (-1,-1), self.custom_font),
            ('FONTSIZE', (0,0), (-1,-1), 10),
            ('LEFTPADDING', (0,0), (-1,-1), 0),
            ('BOTTOMPADDING', (0,0), (-1,-1), 5),
        ]))
        self.elements.append(t_dates)
        
        self.elements.append(Paragraph("Miesto pobytu na dovolenke: .....................................................................................", self.styles['VacationText']))
        self.elements.append(Spacer(1, 5*mm))

        # --- 4. PODPIS (UPRAVENÉ) ---
        today_str = date.today().strftime("%d. %m. %Y")
        data_sig = [
            [f"{today_str}", "........................................................"],
            ["Dátum", "podpis pracovníka"]
        ]
        t_sig = Table(data_sig, colWidths=[60*mm, 80*mm])
        t_sig.setStyle(TableStyle([
            # Zarovnanie na stred pre oba stĺpce (Dátum aj Podpis)
            ('ALIGN', (0,0), (-1,-1), 'CENTER'),
            # Odstránené čiary (LINEABOVE)
            ('FONTSIZE', (0,1), (-1,1), 7), # Menší font pre popisky
            ('VALIGN', (0,0), (-1,-1), 'TOP'),
        ]))
        self.elements.append(t_sig)
        self.elements.append(Spacer(1, 5*mm))

        # --- 5. SCHVAĽOVACIA TABUĽKA ---
        data_approval = [
            ["", "Dátum", "Ved. Útvaru", "Pers. odbor"],
            ["Schválil", "", "", ""],
            ["Skutočný nástup dovolenky", "", "", ""],
            ["Nástup do zam. po dovolenke", "", "", ""],
            [f"Z tejto dovolenky sa skutočne čerpalo: {work_days} prac. dní", "", "", ""]
        ]
        
        t_app = Table(data_approval, colWidths=[80*mm, 25*mm, 35*mm, 35*mm], rowHeights=8*mm)
        t_app.setStyle(TableStyle([
            ('GRID', (0,0), (-1,-1), 1, colors.black),
            ('FONTNAME', (0,0), (-1,-1), self.custom_font_bold),
            ('FONTSIZE', (0,0), (-1,-1), 8),
            ('ALIGN', (0,0), (-1,-1), 'CENTER'),
            ('VALIGN', (0,0), (-1,-1), 'MIDDLE'),
            ('ALIGN', (0,1), (0,-1), 'LEFT'),
            ('SPAN', (0,4), (1,4)),
        ]))
        self.elements.append(t_app)
        
        self.elements.append(Spacer(1, 2*mm))
        self.elements.append(Paragraph("Poznámky o mzdových nárokoch, neodovzdaných nástrojoch uveďte na zadnej strane.", self.styles['VacationLabel']))

        self.elements.append(PageBreak())

    def generate_response(self):
        VACATION_IDS = [21, 5] 

        days_in_month = monthrange(self.year, self.month)[1]
        start_date = date(self.year, self.month, 1)
        end_date = date(self.year, self.month, days_in_month)

        shifts = PlannedShifts.objects.filter(
            user_id=self.employee_id,
            date__range=(start_date, end_date),
            type_shift__id__in=VACATION_IDS
        ).order_by('date')

        grouped_shifts = self._group_consecutive_dates(list(shifts))

        if not grouped_shifts:
            self.elements.append(Paragraph("V tomto období nebola nájdená žiadna plánovaná dovolenka.", self.styles['VacationText']))
            self.doc.build(self.elements, onFirstPage=self._draw_border, onLaterPages=self._draw_border)
            pdf = self.buffer.getvalue()
            self.buffer.close()
            response = HttpResponse(content_type='application/pdf')
            response['Content-Disposition'] = f'attachment; filename="Ziadna_dovolenka.pdf"'
            response.write(pdf)
            return response

        for group in grouped_shifts:
            self._draw_form(group)

        self.doc.build(self.elements, onFirstPage=self._draw_border, onLaterPages=self._draw_border)
        
        pdf = self.buffer.getvalue()
        self.buffer.close()
        
        response = HttpResponse(content_type='application/pdf')
        filename = f"Dovolenky_{self.employee.last_name}_{self.month}_{self.year}.pdf" if self.employee else "Dovolenky.pdf"
        response['Content-Disposition'] = f'attachment; filename="{filename}"'
        response.write(pdf)
        return response
#end
</file>

<file path="WorkTrackApi/management/__inyt__.py">

</file>

<file path="WorkTrackApi/management/commands/check_missing_attendance.py">
from django.core.management.base import BaseCommand
from datetime import date
from WorkTrackApi.models import PlannedShifts, Attendance

class Command(BaseCommand):
    help = "Spracuje minulé smeny: Dovolenky/PN potvrdí, Absencie označí na schválenie"

    def handle(self, *args, **kwargs):
        today = date.today()

        # Nájdeme kandidátov (Staršie ako dnes, neskryté, bez zmeny)
        planned_shifts = PlannedShifts.objects.filter(
            date__lt=today,
            hidden=False,
            is_changed=False,
            transferred=False 
        )

        count_absences = 0
        count_auto_created = 0

        for shift in planned_shifts:
            # Hľadáme dochádzku k tejto smene
            exists = Attendance.objects.filter(planned_shift=shift).exists()

            if not exists:
                # =========================================================
                # SCENÁR A: Je to DOVOLENKA (21) alebo PN (23)?
                # -> Automaticky vytvoríme Attendance (potvrdenie čerpania)
                # =========================================================
                if shift.type_shift.id in [21, 23]:
                    Attendance.objects.create(
                        user=shift.user,
                        date=shift.date,
                        planned_shift=shift,
                        type_shift=shift.type_shift,
                        # Predpokladáme, že plán má vyplnené časy. 
                        # Ak nie, treba tu dať fallback (napr. 08:00 - 16:00)
                        custom_start=shift.custom_start, 
                        custom_end=shift.custom_end,
                        calendar_day=shift.calendar_day,
                        note="Automaticky potvrdené systémom (Plánované voľno)"
                    )
                    count_auto_created += 1
                    self.stdout.write(f"✅ {shift.user} {shift.date} – Vytvorená dochádzka ({shift.type_shift.nameShift})")

                # =========================================================
                # SCENÁR B: Bežná smena bez dochádzky (Absencia)
                # -> Skryjeme, nastavíme is_changed, ale NEZADÁME dôvod
                # =========================================================
                else:
                    shift.is_changed = True
                    shift.hidden = True          # Skryjeme z výpočtov
                    
                    shift.change_reason = None   # Dôvod musí zadať človek
                    shift.approval_status = 'pending' # Svieti na Dashboarde
                    
                    shift.note = "⚠️ Chýbajúca dochádzka - Nutné zadať dôvod!"
                    
                    shift.save(update_fields=[
                        "is_changed", "hidden", "change_reason", 
                        "approval_status", "note"
                    ])
                    
                    count_absences += 1
                    self.stdout.write(f"❗ {shift.user} {shift.date} – Čaká na manažéra (Dôvod nezadaný)")

        # Finálny výpis
        self.stdout.write(self.style.SUCCESS(
            f"HOTOVO:\n"
            f" - Automaticky potvrdené (Dovolenka/PN): {count_auto_created}\n"
            f" - Vyžaduje zásah manažéra (Absencie): {count_absences}"
        ))
</file>

<file path="WorkTrackApi/migrations/__init__.py">

</file>

<file path="WorkTrackApi/migrations/0001_initial.py">
# Generated by Django 5.2 on 2025-06-24 16:04

import django.contrib.auth.models
import django.contrib.auth.validators
import django.core.validators
import django.utils.timezone
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('auth', '0012_alter_user_first_name_max_length'),
    ]

    operations = [
        migrations.CreateModel(
            name='Employees',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('password', models.CharField(max_length=128, verbose_name='password')),
                ('last_login', models.DateTimeField(blank=True, null=True, verbose_name='last login')),
                ('is_superuser', models.BooleanField(default=False, help_text='Designates that this user has all permissions without explicitly assigning them.', verbose_name='superuser status')),
                ('username', models.CharField(error_messages={'unique': 'A user with that username already exists.'}, help_text='Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.', max_length=150, unique=True, validators=[django.contrib.auth.validators.UnicodeUsernameValidator()], verbose_name='username')),
                ('first_name', models.CharField(blank=True, max_length=150, verbose_name='first name')),
                ('last_name', models.CharField(blank=True, max_length=150, verbose_name='last name')),
                ('email', models.EmailField(blank=True, max_length=254, verbose_name='email address')),
                ('is_staff', models.BooleanField(default=False, help_text='Designates whether the user can log into this admin site.', verbose_name='staff status')),
                ('is_active', models.BooleanField(default=True, help_text='Designates whether this user should be treated as active. Unselect this instead of deleting accounts.', verbose_name='active')),
                ('date_joined', models.DateTimeField(default=django.utils.timezone.now, verbose_name='date joined')),
                ('personal_number', models.CharField(max_length=3, unique=True, validators=[django.core.validators.RegexValidator(message='Osobné číslo musí mať presne 3 číslice (napr. 001, 123).', regex='^\\d{3}$')])),
                ('role', models.CharField(choices=[('admin', 'Administrátor'), ('manager', 'Manažér'), ('worker', 'Zamestnanec')], default='worker', max_length=20)),
                ('groups', models.ManyToManyField(blank=True, help_text='The groups this user belongs to. A user will get all permissions granted to each of their groups.', related_name='user_set', related_query_name='user', to='auth.group', verbose_name='groups')),
                ('user_permissions', models.ManyToManyField(blank=True, help_text='Specific permissions for this user.', related_name='user_set', related_query_name='user', to='auth.permission', verbose_name='user permissions')),
            ],
            options={
                'verbose_name': 'user',
                'verbose_name_plural': 'users',
                'abstract': False,
            },
            managers=[
                ('objects', django.contrib.auth.models.UserManager()),
            ],
        ),
    ]
</file>

<file path="WorkTrackApi/migrations/0002_typeshift.py">
# Generated by Django 5.2 on 2025-06-25 02:01

import django.core.validators
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('WorkTrackApi', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='TypeShift',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('nameShift', models.CharField(max_length=20, unique=True, validators=[django.core.validators.RegexValidator(message='Názov smeny môže obsahovať len písmená, čísla, medzery a pomlčky.', regex='^[A-Za-z0-9\\s\\-]+$')])),
                ('start_time', models.TimeField(max_length=4)),
                ('end_time', models.TimeField(max_length=4)),
                ('duration_time', models.DecimalField(decimal_places=2, max_digits=4, validators=[django.core.validators.MinValueValidator(0.5, message='Trvanie musí byť aspoň 0.5 hodiny'), django.core.validators.MaxValueValidator(24.0, message='Trvanie nemôže byť viac ako 24 hodín')])),
            ],
        ),
    ]
</file>

<file path="WorkTrackApi/migrations/0003_alter_typeshift_nameshift_attendance.py">
# Generated by Django 5.2 on 2025-06-27 18:44

import django.core.validators
import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('WorkTrackApi', '0002_typeshift'),
    ]

    operations = [
        migrations.AlterField(
            model_name='typeshift',
            name='nameShift',
            field=models.CharField(max_length=20, unique=True, validators=[django.core.validators.RegexValidator(message='Názov smeny môže obsahovať len písmená, čísla, medzery a pomlčky.', regex='^[A-Za-z0-9\\s,\\-]+$')]),
        ),
        migrations.CreateModel(
            name='Attendance',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('date', models.DateField()),
                ('custom_start', models.TimeField(blank=True, null=True)),
                ('custom_end', models.TimeField(blank=True, null=True)),
                ('note', models.TextField(blank=True)),
                ('type_shift', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, to='WorkTrackApi.typeshift')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'unique_together': {('user', 'date')},
            },
        ),
    ]
</file>

<file path="WorkTrackApi/migrations/0004_changereason_plannedshifts.py">
# Generated by Django 5.2 on 2025-06-30 19:13

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('WorkTrackApi', '0003_alter_typeshift_nameshift_attendance'),
    ]

    operations = [
        migrations.CreateModel(
            name='ChangeReason',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('code', models.CharField(max_length=50, unique=True)),
                ('description', models.CharField(max_length=255)),
            ],
        ),
        migrations.CreateModel(
            name='PlannedShifts',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('date', models.DateField()),
                ('custom_start', models.TimeField(blank=True, null=True)),
                ('custom_end', models.TimeField(blank=True, null=True)),
                ('note', models.TextField(blank=True)),
                ('is_changed', models.BooleanField(default=False)),
                ('change_reason', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, to='WorkTrackApi.changereason')),
                ('type_shift', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, to='WorkTrackApi.typeshift')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'unique_together': {('user', 'date')},
            },
        ),
    ]
</file>

<file path="WorkTrackApi/migrations/0005_alter_typeshift_nameshift.py">
# Generated by Django 5.2 on 2025-06-30 20:10

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('WorkTrackApi', '0004_changereason_plannedshifts'),
    ]

    operations = [
        migrations.AlterField(
            model_name='typeshift',
            name='nameShift',
            field=models.CharField(max_length=50),
        ),
    ]
</file>

<file path="WorkTrackApi/migrations/0006_alter_attendance_unique_together.py">
# Generated by Django 5.2 on 2025-07-07 10:24

from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        ('WorkTrackApi', '0005_alter_typeshift_nameshift'),
    ]

    operations = [
        migrations.AlterUniqueTogether(
            name='attendance',
            unique_together=set(),
        ),
    ]
</file>

<file path="WorkTrackApi/migrations/0007_plannedshifts_transferred.py">
# Generated by Django 5.2 on 2025-07-07 20:40

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('WorkTrackApi', '0006_alter_attendance_unique_together'),
    ]

    operations = [
        migrations.AddField(
            model_name='plannedshifts',
            name='transferred',
            field=models.BooleanField(default=False),
        ),
    ]
</file>

<file path="WorkTrackApi/migrations/0008_alter_plannedshifts_change_reason.py">
# Generated by Django 5.2 on 2025-07-08 19:20

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('WorkTrackApi', '0007_plannedshifts_transferred'),
    ]

    operations = [
        migrations.AlterField(
            model_name='plannedshifts',
            name='change_reason',
            field=models.CharField(blank=True, max_length=255, null=True),
        ),
    ]
</file>

<file path="WorkTrackApi/migrations/0009_alter_plannedshifts_unique_together.py">
# Generated by Django 5.2 on 2025-07-08 19:23

from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        ('WorkTrackApi', '0008_alter_plannedshifts_change_reason'),
    ]

    operations = [
        migrations.AlterUniqueTogether(
            name='plannedshifts',
            unique_together={('user', 'date', 'custom_start', 'custom_end')},
        ),
    ]
</file>

<file path="WorkTrackApi/migrations/0010_attendance_exchanged_with.py">
# Generated by Django 5.2 on 2025-07-08 19:43

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('WorkTrackApi', '0009_alter_plannedshifts_unique_together'),
    ]

    operations = [
        migrations.AddField(
            model_name='attendance',
            name='exchanged_with',
            field=models.ForeignKey(blank=True, help_text='Pôvodná smena kolegu, ktorú zamestnanec prebral', null=True, on_delete=django.db.models.deletion.SET_NULL, to='WorkTrackApi.plannedshifts'),
        ),
    ]
</file>

<file path="WorkTrackApi/migrations/0011_calendarday.py">
# Generated by Django 5.2 on 2025-07-09 02:09

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('WorkTrackApi', '0010_attendance_exchanged_with'),
    ]

    operations = [
        migrations.CreateModel(
            name='CalendarDay',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('date', models.DateField(unique=True)),
                ('day', models.CharField(max_length=20)),
                ('is_weekend', models.BooleanField(default=False)),
                ('is_holiday', models.BooleanField(default=False)),
            ],
        ),
    ]
</file>

<file path="WorkTrackApi/migrations/0012_calendarday_holiday_name.py">
# Generated by Django 5.2 on 2025-07-09 02:14

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('WorkTrackApi', '0011_calendarday'),
    ]

    operations = [
        migrations.AddField(
            model_name='calendarday',
            name='holiday_name',
            field=models.CharField(blank=True, max_length=100, null=True),
        ),
    ]
</file>

<file path="WorkTrackApi/migrations/0013_attendance_calendar_day_plannedshifts_calendar_day.py">
# Generated by Django 5.2 on 2025-07-09 02:35

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('WorkTrackApi', '0012_calendarday_holiday_name'),
    ]

    operations = [
        migrations.AddField(
            model_name='attendance',
            name='calendar_day',
            field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='attendances', to='WorkTrackApi.calendarday'),
        ),
        migrations.AddField(
            model_name='plannedshifts',
            name='calendar_day',
            field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='planned_shifts', to='WorkTrackApi.calendarday'),
        ),
    ]
</file>

<file path="WorkTrackApi/migrations/0014_remove_changereason_code_changereason_category_and_more.py">
# Generated by Django 5.2 on 2025-07-11 08:36

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('WorkTrackApi', '0013_attendance_calendar_day_plannedshifts_calendar_day'),
    ]

    operations = [
        migrations.RemoveField(
            model_name='changereason',
            name='code',
        ),
        migrations.AddField(
            model_name='changereason',
            name='category',
            field=models.CharField(choices=[('absence', 'Neprítomnosť / zmena rozpisu'), ('cdr', 'Iná činnosť zamestnanca ')], default='other', max_length=50),
        ),
        migrations.AddField(
            model_name='changereason',
            name='name',
            field=models.CharField(default='Dôvod nezadaný', max_length=255),
        ),
        migrations.AlterField(
            model_name='changereason',
            name='description',
            field=models.TextField(blank=True),
        ),
    ]
</file>

<file path="WorkTrackApi/migrations/0015_typeshift_allow_variable_time_and_more.py">
# Generated by Django 5.2 on 2025-07-11 10:50

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('WorkTrackApi', '0014_remove_changereason_code_changereason_category_and_more'),
    ]

    operations = [
        migrations.AddField(
            model_name='typeshift',
            name='allow_variable_time',
            field=models.BooleanField(default=False, help_text='Ak je zapnuté, zamestnanec môže prísť a odísť kedykoľvek (napr. flexibilná smena).'),
        ),
        migrations.AlterField(
            model_name='changereason',
            name='category',
            field=models.CharField(choices=[('absence', 'Neprítomnosť / zmena rozpisu'), ('cdr', 'Iná činnosť zamestnanca ')], max_length=10),
        ),
        migrations.AlterField(
            model_name='plannedshifts',
            name='calendar_day',
            field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='planned_shifts', to='WorkTrackApi.changereason'),
        ),
        migrations.AlterField(
            model_name='plannedshifts',
            name='change_reason',
            field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='change_reason', to='WorkTrackApi.calendarday'),
        ),
        migrations.AlterField(
            model_name='typeshift',
            name='end_time',
            field=models.TimeField(),
        ),
        migrations.AlterField(
            model_name='typeshift',
            name='start_time',
            field=models.TimeField(),
        ),
    ]
</file>

<file path="WorkTrackApi/migrations/0016_alter_plannedshifts_calendar_day_and_more.py">
# Generated by Django 5.2 on 2025-07-11 10:56

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('WorkTrackApi', '0015_typeshift_allow_variable_time_and_more'),
    ]

    operations = [
        migrations.AlterField(
            model_name='plannedshifts',
            name='calendar_day',
            field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='calendar_day', to='WorkTrackApi.calendarday'),
        ),
        migrations.AlterField(
            model_name='plannedshifts',
            name='change_reason',
            field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='change_reason', to='WorkTrackApi.changereason'),
        ),
    ]
</file>

<file path="WorkTrackApi/migrations/0017_plannedshifts_hidden.py">
# Generated by Django 5.2 on 2025-07-11 20:06

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('WorkTrackApi', '0016_alter_plannedshifts_calendar_day_and_more'),
    ]

    operations = [
        migrations.AddField(
            model_name='plannedshifts',
            name='hidden',
            field=models.BooleanField(default=False),
        ),
    ]
</file>

<file path="WorkTrackApi/migrations/0018_attendance_planned_shift_and_more.py">
# Generated by Django 5.2 on 2025-07-12 17:58

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('WorkTrackApi', '0017_plannedshifts_hidden'),
    ]

    operations = [
        migrations.AddField(
            model_name='attendance',
            name='planned_shift',
            field=models.ForeignKey(blank=True, help_text='Vybraná plánovaná smena, z ktorej sa preberajú časy', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='attendances_as_planned', to='WorkTrackApi.plannedshifts'),
        ),
        migrations.AlterField(
            model_name='attendance',
            name='exchanged_with',
            field=models.ForeignKey(blank=True, help_text='Pôvodná smena kolegu, ktorú zamestnanec prebral', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='attendances_as_exchanged_with', to='WorkTrackApi.plannedshifts'),
        ),
    ]
</file>

<file path="WorkTrackApi/migrations/0019_alter_plannedshifts_date.py">
# Generated by Django 5.2 on 2025-07-12 18:48

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('WorkTrackApi', '0018_attendance_planned_shift_and_more'),
    ]

    operations = [
        migrations.AlterField(
            model_name='plannedshifts',
            name='date',
            field=models.DateField(blank=True, null=True),
        ),
    ]
</file>

<file path="WorkTrackApi/migrations/0020_alter_attendance_options_alter_attendance_date_and_more.py">
# Generated by Django 5.2 on 2025-07-30 02:11

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('WorkTrackApi', '0019_alter_plannedshifts_date'),
    ]

    operations = [
        migrations.AlterModelOptions(
            name='attendance',
            options={'ordering': ['date', 'user']},
        ),
        migrations.AlterField(
            model_name='attendance',
            name='date',
            field=models.DateField(blank=True, null=True),
        ),
        migrations.AlterUniqueTogether(
            name='attendance',
            unique_together={('user', 'date', 'custom_start', 'custom_end')},
        ),
    ]
</file>

<file path="WorkTrackApi/migrations/0021_alter_typeshift_duration_time_and_more.py">
# Generated by Django 5.2 on 2025-08-02 02:21

import django.core.validators
from decimal import Decimal
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('WorkTrackApi', '0020_alter_attendance_options_alter_attendance_date_and_more'),
    ]

    operations = [
        migrations.AlterField(
            model_name='typeshift',
            name='duration_time',
            field=models.DecimalField(blank=True, decimal_places=2, max_digits=4, null=True, validators=[django.core.validators.MinValueValidator(Decimal('0.5'), message='Trvanie musí byť aspoň 0.5 hodiny'), django.core.validators.MaxValueValidator(Decimal('24.0'), message='Trvanie nemôže byť viac ako 24 hodín')]),
        ),
        migrations.AlterField(
            model_name='typeshift',
            name='end_time',
            field=models.TimeField(blank=True, null=True),
        ),
        migrations.AlterField(
            model_name='typeshift',
            name='start_time',
            field=models.TimeField(blank=True, null=True),
        ),
    ]
</file>

<file path="WorkTrackApi/migrations/0022_typeshift_shortname.py">
# Generated by Django 5.2 on 2025-08-18 15:37

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('WorkTrackApi', '0021_alter_typeshift_duration_time_and_more'),
    ]

    operations = [
        migrations.AddField(
            model_name='typeshift',
            name='shortName',
            field=models.CharField(default='ds', max_length=2),
        ),
    ]
</file>

<file path="WorkTrackApi/migrations/0023_alter_plannedshifts_user.py">
# Generated by Django 5.2 on 2025-08-18 19:10

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('WorkTrackApi', '0022_typeshift_shortname'),
    ]

    operations = [
        migrations.AlterField(
            model_name='plannedshifts',
            name='user',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='planned_shifts', to=settings.AUTH_USER_MODEL),
        ),
    ]
</file>

<file path="WorkTrackApi/migrations/0024_alter_plannedshifts_calendar_day.py">
# Generated by Django 5.2 on 2026-01-22 10:48

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('WorkTrackApi', '0023_alter_plannedshifts_user'),
    ]

    operations = [
        migrations.AlterField(
            model_name='plannedshifts',
            name='calendar_day',
            field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='planned_calendar_day', to='WorkTrackApi.calendarday'),
        ),
    ]
</file>

<file path="WorkTrackApi/migrations/0025_employees_initial_hours_balance.py">
# Generated by Django 5.2 on 2026-01-27 08:19

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('WorkTrackApi', '0024_alter_plannedshifts_calendar_day'),
    ]

    operations = [
        migrations.AddField(
            model_name='employees',
            name='initial_hours_balance',
            field=models.DecimalField(decimal_places=2, default=0.0, help_text='Počiatočný stav prenesených hodín (napr. +10.5 alebo -5.0) pri nástupe alebo štarte systému.', max_digits=6),
        ),
    ]
</file>

<file path="WorkTrackApi/migrations/0026_plannedshifts_approval_status_and_more.py">
# Generated by Django 5.2 on 2026-01-27 12:07

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('WorkTrackApi', '0025_employees_initial_hours_balance'),
    ]

    operations = [
        migrations.AddField(
            model_name='plannedshifts',
            name='approval_status',
            field=models.CharField(choices=[('pending', 'Čaká na schválenie'), ('approved', 'Schválené'), ('rejected', 'Zamietnuté')], default='pending', max_length=10),
        ),
        migrations.AddField(
            model_name='plannedshifts',
            name='manager_note',
            field=models.TextField(blank=True, null=True),
        ),
    ]
</file>

<file path="WorkTrackApi/models.py">
from django.contrib.auth.models import AbstractUser
from django.db import models
from django.core.validators import RegexValidator, MaxValueValidator, MinValueValidator
from django.core.exceptions import ValidationError
from datetime import datetime
from decimal import Decimal
from datetime import date, datetime, timedelta, time
import threading
import calendar
from .utils.attendance_utils import (
    round_to_nearest_half_hour
)

_thread_locals = threading.local()

def set_force_shift_times(value: bool):
    _thread_locals.force_shift_times = value

def get_force_shift_times():
    return getattr(_thread_locals, 'force_shift_times', False)
class Employees(AbstractUser):
    personal_number=models.CharField(max_length=3, 
                                     unique=True,
                                     validators=[RegexValidator(
                                         regex=r'^\d{3}$', message='Osobné číslo musí mať presne 3 číslice (napr. 001, 123).'
                                     )])
    
    ROLE_CHOICES=[
         ('admin', 'Administrátor' ),
        ('manager', 'Manažér'),
        ('worker', 'Zamestnanec'),
    ]
    role = models.CharField(max_length=20, choices=ROLE_CHOICES, default='worker')

    

    USERNAME_FIELD = 'username'
    REQUIRED_FIELDS = ['email', 'first_name', 'last_name', 'personal_number']
    initial_hours_balance = models.DecimalField(
            max_digits=6, 
            decimal_places=2, 
            default=0.00,
            help_text="Počiatočný stav prenesených hodín (napr. +10.5 alebo -5.0) pri nástupe alebo štarte systému."
        )
    def __str__(self):
        return f"{self.first_name} {self.last_name} ({self.personal_number})"

"""VYTVORIT PODMINKU AK PLANUJEM SMENU NADAJU SA MENIT CASY"""

class TypeShift(models.Model):
    nameShift = models.CharField(max_length=50)
    start_time = models.TimeField(null=True, blank=True)
    end_time = models.TimeField(null=True, blank=True)
    duration_time = models.DecimalField(
        null=True, blank=True,
        max_digits=4, decimal_places=2,
        validators=[
            MinValueValidator(Decimal("0.5"), message="Trvanie musí byť aspoň 0.5 hodiny"),
            MaxValueValidator(Decimal("24.0"), message="Trvanie nemôže byť viac ako 24 hodín")
        ]
    )
    
    allow_variable_time = models.BooleanField(
        default=False,
        help_text="Ak je zapnuté, zamestnanec môže prísť a odísť kedykoľvek (napr. flexibilná smena)."
    )
    shortName = models.CharField(max_length=2,default="ds")
    def __str__(self):
        return self.nameShift

    def clean(self):
        # povinné len ak nejde o typ s id=22 (alebo ešte neexistuje a nameShift nie je špeciálne)
        if self.id != 22:
            missing = []
            if not self.start_time:
                missing.append("start_time")
            if not self.end_time:
                missing.append("end_time")
            if not self.duration_time:
                missing.append("duration_time")
            if missing:
                raise ValidationError(f"Tieto polia sú povinné pre túto smenu: {', '.join(missing)}")

    def save(self, *args, **kwargs):
        self.full_clean()  # spustí clean() pred uložením

         # prepočítavaj iba pre typ smeny s ID 22
        if self.pk == 22:  
            start_dt = datetime.combine(datetime.today(), self.start_time)
            end_dt = datetime.combine(datetime.today(), self.end_time)

            # ak smena ide cez polnoc (napr. 22:00 → 06:00)
            if end_dt <= start_dt:
                end_dt += timedelta(days=1)

            duration = end_dt - start_dt
            total_minutes = duration.seconds // 60
            h = total_minutes // 60
            m = total_minutes % 60

            self.duration_time = f"{h:02d}:{m:02d}"

        super().save(*args, **kwargs)

"""emploee time at work"""
class Attendance(models.Model):
    user= models.ForeignKey(Employees, on_delete=models.CASCADE)
    date = models.DateField(null=True, blank=True)
    type_shift= models.ForeignKey(TypeShift, null=True, blank=True, on_delete=models.SET_NULL)
    planned_shift = models.ForeignKey('WorkTrackApi.PlannedShifts',
    null=True,
    blank=True,
    on_delete=models.SET_NULL,
    help_text="Vybraná plánovaná smena, z ktorej sa preberajú časy",
    related_name="attendances_as_planned"
)

    custom_start= models.TimeField(null=True, blank=True)
    custom_end= models.TimeField(null=True,blank=True)
    note= models.TextField(blank=True)
    exchanged_with = models.ForeignKey('WorkTrackApi.PlannedShifts',                   
                null=True,
                blank=True,
                on_delete=models.SET_NULL,
                help_text="Pôvodná smena kolegu, ktorú zamestnanec prebral",
                related_name="attendances_as_exchanged_with"
            )

    
    calendar_day = models.ForeignKey('WorkTrackApi.CalendarDay', on_delete=models.CASCADE, related_name="attendances",null=True, blank=True)

    class Meta:
            unique_together = ('user', 'date', 'custom_start', 'custom_end')
            ordering = ['date', 'user']

    def __str__(self):
        return f"{self.user} - {self.date} ({self.custom_start} - {self.custom_end})"


    def save(self, *args, **kwargs):
        # Pri update aktualizuj calendar_day, ak sa mení dátum
        if self.pk:
            orig_attendance = Attendance.objects.get(pk=self.pk)

            if self.date != orig_attendance.date:
                try:
                    self.calendar_day = CalendarDay.objects.get(date=self.date)
                except CalendarDay.DoesNotExist:
                    raise ValidationError(f"Pre dátum {self.date} neexistuje CalendarDay.")
        else:
            # Pri vytváraní nastav calendar_day podľa dátumu
            if self.date and not self.calendar_day:
                try:
                    self.calendar_day = CalendarDay.objects.get(date=self.date)
                except CalendarDay.DoesNotExist:
                    raise ValidationError(f"CalendarDay pre dátum {self.date} neexistuje.")

        # Ak attendance nemá custom časy, môžeš ich nastaviť podľa type_shift (ak existuje)
        if self.type_shift:
            if not self.custom_start:
                self.custom_start = self.type_shift.start_time
            if not self.custom_end:
                self.custom_end = self.type_shift.end_time

        # Validácia časov custom_start a custom_end
        if self.custom_start and self.custom_end:
            start = datetime.combine(date.today(), self.custom_start)
            end = datetime.combine(date.today(), self.custom_end)
            if end <= start:
                end += timedelta(days=1)
                if end <= start:
                    raise ValidationError("Koniec smeny musí byť po začiatku (alebo správna nočná smena).")

        super().save(*args, **kwargs)
       

   
    

"""Change reason"""
class ChangeReason(models.Model):
    CATEGORY_CHOICES = [
        ('absence', 'Neprítomnosť / zmena rozpisu'),
        ('cdr', 'Iná činnosť zamestnanca '),
    ]

    name = models.CharField(max_length=255, default="Dôvod nezadaný")
    description = models.TextField(blank=True)
    category = models.CharField(max_length=10, choices=CATEGORY_CHOICES)

    def __str__(self):
        return self.name
    

"""planned shifts"""



class PlannedShifts(models.Model):
    user = models.ForeignKey('WorkTrackApi.Employees', on_delete=models.CASCADE, related_name='planned_shifts')
    date = models.DateField(null=True, blank=True)
    type_shift = models.ForeignKey('WorkTrackApi.TypeShift', null=True, blank=True, on_delete=models.SET_NULL)
    
    # Časy smeny (ak sa líšia od defaultu v type_shift)
    custom_start = models.TimeField(null=True, blank=True)
    custom_end = models.TimeField(null=True, blank=True)
    
    note = models.TextField(blank=True)
    
    # Stavové polia
    transferred = models.BooleanField(default=False) # Či už bola preklopená do dochádzky
    is_changed = models.BooleanField(default=False)
    hidden = models.BooleanField(default=False) # Soft delete
    is_changed = models.BooleanField(default=False)
    
    # Prepojenie na tvoj číselník dôvodov
    change_reason = models.ForeignKey(
        'ChangeReason', 
        on_delete=models.SET_NULL, 
        null=True, 
        blank=True,
        related_name='shifts'
    )
    
    # Stav schválenia manažérom
    APPROVAL_CHOICES = [
        ('pending', 'Čaká na schválenie'),
        ('approved', 'Schválené'),
        ('rejected', 'Zamietnuté'),
    ]
    approval_status = models.CharField(
        max_length=10, 
        choices=APPROVAL_CHOICES, 
        default='pending'
    )
    
    manager_note = models.TextField(blank=True, null=True)
    change_reason = models.ForeignKey('WorkTrackApi.ChangeReason', on_delete=models.CASCADE, related_name="change_reason", blank=True, null=True)
    calendar_day = models.ForeignKey('WorkTrackApi.CalendarDay', on_delete=models.CASCADE, related_name="planned_calendar_day", null=True, blank=True)
   
    class Meta:
        # Povolíme viac záznamov na deň? Ak nie, nechaj toto. 
        # Ak chceš, aby mal rannú a potom nočnú v ten istý deň, toto treba zmazať.
        unique_together = ('user', 'date', 'custom_start', 'custom_end')

    def __str__(self):
        return f"{self.user} - {self.date} ({self.type_shift})"

    def save(self, *args, **kwargs):
        # Automatické priradenie CalendarDay podľa dátumu
        if self.date and not self.calendar_day:
            from WorkTrackApi.models import CalendarDay
            try:
                self.calendar_day = CalendarDay.objects.get(date=self.date)
            except CalendarDay.DoesNotExist:
                pass # Alebo raise ValidationError
        super().save(*args, **kwargs) 



class CalendarDay(models.Model):
    date = models.DateField(unique=True)
    day = models.CharField(max_length=20)
    is_weekend = models.BooleanField(default=False)
    is_holiday = models.BooleanField(default=False)
    holiday_name = models.CharField(max_length=100, blank=True, null=True)  

    def __str__(self):
        return f"{self.date} ({self.day})"

    @staticmethod
    def get_easter_sunday(year):
        "Výpočet dátumu Veľkonočnej nedele podľa algoritmu (Computus)"
        a = year % 19
        b = year // 100
        c = year % 100
        d = b // 4
        e = b % 4
        f = (b + 8) // 25
        g = (b - f + 1) // 3
        h = (19 * a + b - d - g + 15) % 30
        i = c // 4
        k = c % 4
        l = (32 + 2 * e + 2 * i - h - k) % 7
        m = (a + 11 * h + 22 * l) // 451
        month = (h + l - 7 * m + 114) // 31
        day = ((h + l - 7 * m + 114) % 31) + 1
        return date(year, month, day)

    @staticmethod
    def get_slovak_holidays(year):
        "Vráti zoznam sviatkov vo forme [(dátum, názov)]"
        fixed = [
            (1, 1, "Deň vzniku SR"),
            (1, 6, "Zjavenie Pána"),
            (5, 1, "Sviatok práce"),
            (5, 8, "Deň víťazstva nad fašizmom"),
            (7, 5, "Sviatok sv. Cyrila a Metoda"),
            (8, 29, "Výročie SNP"),
            (9, 1, "Deň Ústavy SR"),
            (9, 15, "Sedembolestná Panna Mária"),
            (11, 1, "Sviatok všetkých svätých"),
            (11, 17, "Deň boja za slobodu a demokraciu"),
            (12, 24, "Štedrý deň"),
            (12, 25, "1. sviatok vianočný"),
            (12, 26, "2. sviatok vianočný"),
        ]
        movable = []
        easter = CalendarDay.get_easter_sunday(year)
        movable.append((easter - timedelta(days=2), "Veľký piatok"))
        movable.append((easter + timedelta(days=1), "Veľkonočný pondelok"))

        return [(date(year, m, d), name) for m, d, name in fixed] + movable

    @classmethod
    def generate_calendar(cls, start_year, end_year):
        """
        Vygeneruje dni v kalendári pre dané roky, vrátane sviatkov.
        """
        for year in range(start_year, end_year + 1):
            holidays = dict(cls.get_slovak_holidays(year))

            d = date(year, 1, 1)
            while d.year == year:
                weekday_name = calendar.day_name[d.weekday()]
                is_weekend = weekday_name in ["Saturday", "Sunday"]
                is_holiday = d in holidays
                holiday_name = holidays.get(d, "")

                obj, created = cls.objects.get_or_create(
                    date=d,
                    defaults={
                         "day": weekday_name,
                        "is_weekend": is_weekend,
                        "is_holiday": is_holiday,
                        "holiday_name": holiday_name
                    }
                )

                if not created:
                    # aktualizuj ak sa zmenilo
                    obj.day = weekday_name
                    obj.is_weekend = is_weekend
                    obj.is_holiday = is_holiday
                    obj.holiday_name = holiday_name
                    obj.save()

                d += timedelta(days=1)
</file>

<file path="WorkTrackApi/permissions.py">
from rest_framework import permissions

class IsManagerOrReadOnly(permissions.BasePermission):
    """
    Vlastné oprávnenie:
    - Worker (Robotník): Môže iba čítať (GET, HEAD, OPTIONS).
    - Manager / Admin: Môžu robiť všetko (POST, PUT, DELETE).
    """

    def has_permission(self, request, view):
        # 1. Ak používateľ nie je prihlásený, zamietneme prístup
        if not request.user or not request.user.is_authenticated:
            return False

        # 2. Ak je metóda "bezpečná" (GET, HEAD, OPTIONS), povolíme prístup každému prihlásenému
        if request.method in permissions.SAFE_METHODS:
            return True

        # 3. Ak je metóda "zapisovacia" (POST, PUT, DELETE),
        # povolíme to len ak má rolu 'manager' alebo 'admin'
        # (Predpokladáme, že máš v modeli pole 'role')
        return request.user.role in ['manager', 'admin']
</file>

<file path="WorkTrackApi/serializers.py">
from rest_framework import serializers
from .models import Employees, TypeShift,Attendance, PlannedShifts,ChangeReason,CalendarDay
from.utils.attendance_utils import create_attendance_from_planned_shift
from datetime import date as dt_date, datetime, timedelta
from django.core.exceptions import ValidationError
from datetime import time
from django.utils.dateparse import parse_time





class TypeShiftSerializer(serializers.ModelSerializer):
    class Meta:
        model = TypeShift
        fields = ['id', 'nameShift', 'start_time', 'end_time', 'duration_time','shortName','allow_variable_time']

class ChangeReasonSerializers(serializers.ModelSerializer):
    class Meta:
        model = ChangeReason
        fields = '__all__'




class PlannedShiftsSerializer(serializers.ModelSerializer):
    shift_name = serializers.CharField(source='type_shift.nameShift', read_only=True)
    short_name = serializers.CharField(source='type_shift.shortName', read_only=True)
    duration = serializers.SerializerMethodField()
# Pre čítanie: Vrátime celý objekt (názov, popis)
    change_reason_details = ChangeReasonSerializers(source='change_reason', read_only=True)
    
    # Pre zápis: Akceptujeme ID
    change_reason_id = serializers.PrimaryKeyRelatedField(
        queryset=ChangeReason.objects.all(), 
        source='change_reason', 
        write_only=True,
        required=False, 
        allow_null=True
    )
    class Meta:
        model = PlannedShifts
        fields = '__all__'
        read_only_fields = ['calendar_day']
        extra_kwargs = {
            'custom_start': {'required': False, 'allow_null': True},
            'custom_end': {'required': False, 'allow_null': True},
        }
        
    def validate(self, data):
        type_shift = data.get('type_shift')
        if not type_shift and self.instance:
            type_shift = self.instance.type_shift

        # --- STRICT MODE LOGIKA ---
        if type_shift:
            if type_shift.id != 22:
                # Pre bežné smeny NATVRDO nastavíme časy z číselníka
                data['custom_start'] = type_shift.start_time
                data['custom_end'] = type_shift.end_time
            else:
                # Pre ID 22 kontrolujeme zaokrúhlenie
                for field in ['custom_start', 'custom_end']:
                    time_val = data.get(field)
                    if time_val:
                        if time_val.minute not in [0, 30] or time_val.second != 0:
                            raise serializers.ValidationError({
                                field: f"Čas v poli {field} musí byť zaokrúhlený na celú hodinu alebo polhodinu."
                            })
        # --------------------------

        # Kontrola prekrývania (Logic Conflict) - skrátená verzia pre prehľadnosť
        user = data.get('user') or (self.instance.user if self.instance else None)
        shift_date = data.get('date') or (self.instance.date if self.instance else None)
        start_time = data.get('custom_start')
        end_time = data.get('custom_end')

        if user and shift_date and start_time and end_time:
            # ... tu ostáva tvoja pôvodná logika kontroly prekrývania ...
            pass 
        
        return data

    def get_duration(self, obj):
        # Vždy vrátiť HH:MM
        start_t = obj.custom_start or (obj.type_shift.start_time if obj.type_shift else None)
        end_t = obj.custom_end or (obj.type_shift.end_time if obj.type_shift else None)

        if start_t and end_t:
            d = datetime.today().date()
            start = datetime.combine(d, start_t)
            end = datetime.combine(d, end_t)
            if end < start: end += timedelta(days=1)
            delta = end - start
            hours, remainder = divmod(int(delta.total_seconds()), 3600)
            minutes, _ = divmod(remainder, 60)
            return f"{hours:02d}:{minutes:02d}"
            
        if obj.type_shift and obj.type_shift.duration_time:
            return str(obj.type_shift.duration_time)
        return None
    def validate_user(self, value):
            """
            Nedovolí priradiť smenu zamestnancovi, ktorý má active=False.
            """
            # Ak vytvárame nový záznam a užívateľ je neaktívny -> CHYBA
            if not value.is_active:
                raise serializers.ValidationError(f"Zamestnanec {value} je neaktívny. Nemožno mu naplánovať smenu.")
            
            return value


class EmployeesSerializer(serializers.ModelSerializer):
    planned_shifts = PlannedShiftsSerializer(many=True, read_only=True)
    class Meta:
        model = Employees
        fields = ['id', 'username', 'email', 'first_name', 'last_name', 'personal_number', 'role','is_active', 'planned_shifts','initial_hours_balance', 'planned_shifts']


class CalendarDaySerializers(serializers.ModelSerializer):
    class Meta:
        model = CalendarDay
        fields = '__all__'



class AttendanceSerializer(serializers.ModelSerializer):
    change_reason_id = serializers.PrimaryKeyRelatedField(
        queryset=ChangeReason.objects.all(),
        write_only=True,
        required=False,
        allow_null=True
    )
    user = serializers.PrimaryKeyRelatedField(
        queryset=Employees.objects.all(), required=False
    )
    
    # 1. ZMENA: QuerySet musí byť .all(), aby sme našli aj skryté (hidden=True) smeny
    planned_shift = serializers.PrimaryKeyRelatedField(
        queryset=PlannedShifts.objects.all(), 
        required=False, 
        allow_null=True
    )

    class Meta:
        model = Attendance
        fields = '__all__'
        extra_kwargs = {
            'date': {'required': False, 'allow_null': True},
        }

    def to_time(self, value):
        if isinstance(value, time): return value
        if isinstance(value, str): 
            parsed = parse_time(value)
            return parsed if parsed else None
        return None

    def validate(self, attrs):
        instance = getattr(self, 'instance', None)
        planned_shift = attrs.get('planned_shift') or (instance.planned_shift if instance else None)
        change_reason = attrs.get('change_reason_id')
        
        input_start = self.to_time(self.initial_data.get('custom_start'))
        input_end = self.to_time(self.initial_data.get('custom_end'))

        # --- VALIDÁCIA ---

        if planned_shift:
            # 2. ZMENA: Ak je smena skrytá (skript ju označil ako absenciu), 
            # zamestnanec MUSÍ zadať dôvod, prečo to zapisuje neskoro.
            if planned_shift.hidden and not change_reason:
                raise serializers.ValidationError({
                    "change_reason_id": "Táto smena bola uzavretá ako chýbajúca. Musíte zadať dôvod dodatočného zápisu (napr. 'Zabudol som')."
                })

            # Validácia zmeny časov
            p_start = planned_shift.custom_start
            p_end = planned_shift.custom_end
            start_changed = input_start is not None and input_start != p_start
            end_changed = input_end is not None and input_end != p_end

            if (start_changed or end_changed) and not change_reason:
                raise serializers.ValidationError({
                    "change_reason_id": f"Čas sa nezhoduje s plánom. Musíte zadať dôvod."
                })
            
            # Strict mode dátumov
            attrs['date'] = planned_shift.date
            if not attrs.get('user'): attrs['user'] = planned_shift.user
        
        elif not instance and not planned_shift:
            if not change_reason:
                raise serializers.ValidationError({
                    "change_reason_id": "Vytvárate smenu mimo plánu. Musíte zadať dôvod."
                })
            if not attrs.get("date"): attrs["date"] = dt_date.today()

        return attrs

    def create(self, validated_data):
        planned_shift = validated_data.get('planned_shift')
        change_reason = validated_data.pop('change_reason_id', None)

        input_start = self.to_time(self.initial_data.get('custom_start'))
        input_end = self.to_time(self.initial_data.get('custom_end'))

        # --- SCENÁR A: MÁME PLÁNOVANÚ SMENU ---
        if planned_shift:
            
            # 3. ZMENA: LOGIKA "OŽIVENIA" (RECOVERY)
            # Ak bola smena hidden (absencia), ale teraz vytvárame dochádzku -> vrátime ju do hry.
            if planned_shift.hidden:
                print(f"🔄 Oživujem skrytú smenu ID {planned_shift.id}")
                planned_shift.hidden = False       # Už nie je skrytá (bude sa rátať)
                planned_shift.is_changed = True    # Bola zmenená (dodatočný zápis)
                planned_shift.approval_status = 'pending' # Manažér to musí schváliť
                
                if change_reason:
                    planned_shift.change_reason = change_reason
                
                planned_shift.note = (planned_shift.note or "") + " (Dodatočný zápis zamestnancom)"
                planned_shift.save()

            # Zvyšok logiky pre zmenu časov (Meškanie atď.)
            is_start_diff = input_start is not None and input_start != planned_shift.custom_start
            is_end_diff = input_end is not None and input_end != planned_shift.custom_end

            if (is_start_diff or is_end_diff) and change_reason:
                planned_shift.is_changed = True
                planned_shift.change_reason = change_reason
                planned_shift.approval_status = 'pending'
                # Ak sme ju práve neodkryli (nebola hidden), tak ju savneme tu
                if not planned_shift.hidden: 
                    planned_shift.save()

            # Nastavenie dát pre Attendance
            validated_data['custom_start'] = input_start if input_start else planned_shift.custom_start
            validated_data['custom_end'] = input_end if input_end else planned_shift.custom_end
            validated_data['type_shift'] = planned_shift.type_shift
            validated_data['calendar_day'] = planned_shift.calendar_day

            return Attendance.objects.create(**validated_data)

        # --- SCENÁR B: BEZ PLÁNU (Shadow Plan) ---
        else:
            # (Tento kód ostáva rovnaký ako predtým)
            user = validated_data.get('user')
            date_obj = validated_data.get('date')
            type_shift = validated_data.get('type_shift')
            if not type_shift:
                 try: type_shift = TypeShift.objects.get(id=22) 
                 except: raise serializers.ValidationError({"type_shift": "Chýba typ smeny."})

            calendar_day = CalendarDay.objects.filter(date=date_obj).first()

            new_shadow_plan = PlannedShifts.objects.create(
                user=user, date=date_obj, type_shift=type_shift,
                custom_start=input_start, custom_end=input_end,
                is_changed=True, transferred=True, 
                change_reason=change_reason,
                approval_status='pending',
                note="Automaticky vytvorené (Mimo plánu)",
                calendar_day=calendar_day
            )

            validated_data['planned_shift'] = new_shadow_plan
            validated_data['custom_start'] = input_start
            validated_data['custom_end'] = input_end
            validated_data['type_shift'] = type_shift
            validated_data['calendar_day'] = calendar_day

            return Attendance.objects.create(**validated_data)





class RosterItemSerializer(serializers.Serializer):
    """
    Tento serializer reprezentuje jednu bunku v Exceli (jeden deň pre jedného človeka).
    """
    user_id = serializers.IntegerField()
    date = serializers.DateField()
    type_shift_id = serializers.IntegerField(required=False, allow_null=True)
    custom_start = serializers.TimeField(required=False, allow_null=True)
    custom_end = serializers.TimeField(required=False, allow_null=True)
    note = serializers.CharField(required=False, allow_blank=True)

class BulkRosterSerializer(serializers.Serializer):
    """
    Tento serializer prijme zoznam všetkých smien na uloženie.
    """
    year = serializers.IntegerField()
    month = serializers.IntegerField()
    shifts = RosterItemSerializer(many=True)
#end
</file>

<file path="WorkTrackApi/services.py">
from datetime import date, timedelta, datetime, time
from calendar import monthrange
from WorkTrackApi.models import CalendarDay, Attendance, Employees, PlannedShifts
from django.db.models import Sum
from dateutil.relativedelta import relativedelta

NON_WORKING_SHIFT_IDS = [21, 23]
STANDARD_WORK_HOURS = 7.0  # <--- Vaša konštanta pre fond

# ==========================================
# 1. POMOCNÉ FUNKCIE
# ==========================================

def get_previous_month(year, month):
    if month == 1: return year - 1, 12
    return year, month - 1

def get_next_month(year, month):
    if month == 12: return year + 1, 1
    return year, month + 1

def _calculate_night_overlap(range_start, range_end):
    """
    ŠPECIÁLNA FUNKCIA PRE NOČNÚ (Fix pre ID 800 - 10h bug).
    Kontroluje prienik s blokmi 22:00 - 06:00(+1) pre každý dotknutý deň.
    """
    total_seconds = 0.0
    check_date = range_start.date() - timedelta(days=1)
    end_date = range_end.date()

    while check_date <= end_date:
        night_start = datetime.combine(check_date, time(22, 0))
        night_end = datetime.combine(check_date + timedelta(days=1), time(6, 0))

        overlap_start = max(range_start, night_start)
        overlap_end = min(range_end, night_end)

        if overlap_start < overlap_end:
            total_seconds += (overlap_end - overlap_start).total_seconds()

        check_date += timedelta(days=1)

    return total_seconds

def _get_duration(att):
    """Vypočíta trvanie (čas vs fixné) pre ATTENDANCE."""
    CALCULATE_BY_TIME_IDS = [20, 22] 
    
    if att.type_shift and att.type_shift.id in CALCULATE_BY_TIME_IDS:
        if att.custom_start and att.custom_end:
            s = datetime.combine(att.date, att.custom_start)
            e = datetime.combine(att.date, att.custom_end)
            if e < s: e += timedelta(days=1)
            if att.custom_end == time(0, 0) and s == e: e += timedelta(days=1)
            return (e - s).total_seconds() / 3600.0

    if att.type_shift and att.type_shift.duration_time:
        return float(att.type_shift.duration_time)

    if att.custom_start and att.custom_end:
        s = datetime.combine(att.date, att.custom_start)
        e = datetime.combine(att.date, att.custom_end)
        if e < s: e += timedelta(days=1)
        if att.custom_end == time(0, 0) and s == e: e += timedelta(days=1)
        return (e - s).total_seconds() / 3600.0
    return 0.0

# ==========================================
# 2. VÝPOČET FONDU
# ==========================================

def calculate_working_fund(year, month):
    days = monthrange(year, month)[1]
    hours = 0.0
    holidays = {h[0] for h in CalendarDay.get_slovak_holidays(year)}
    
    for day in range(1, days + 1):
        d = date(year, month, day)
        if d.weekday() < 5 and d not in holidays: 
            hours += STANDARD_WORK_HOURS
            
    return hours

def calculate_paid_holiday_credit(employee_id, year, month):
    start, end = date(year, month, 1), date(year, month, monthrange(year, month)[1])
    holidays = CalendarDay.get_slovak_holidays(year)
    credit = 0.0
    
    for h_date, _ in holidays:
        if start <= h_date <= end and h_date.weekday() < 5:
            if not Attendance.objects.filter(user_id=employee_id, date=h_date).exists():
                credit += STANDARD_WORK_HOURS
                
    return credit

# ==========================================
# 3. VÝPOČTY ODRACOVANÝCH HODÍN (Attendance)
# ==========================================

def calculate_worked_hours(employee_id, year, month):
    start, end = date(year, month, 1), date(year, month, monthrange(year, month)[1])
    atts = Attendance.objects.filter(user_id=employee_id, date__range=(start, end)).distinct()
    return round(sum(_get_duration(a) for a in atts), 2)

def calculate_night_shift_hours(employee_id, year, month):
    start, end = date(year, month, 1), date(year, month, monthrange(year, month)[1])
    atts = Attendance.objects.filter(user_id=employee_id, date__range=(start, end)).distinct()
    
    total_seconds = 0.0
    for att in atts:
        if not (att.custom_start and att.custom_end): continue
        s = datetime.combine(att.date, att.custom_start)
        e = datetime.combine(att.date, att.custom_end)
        if e < s: e += timedelta(days=1)
        if att.custom_end == time(0, 0) and s == e: e += timedelta(days=1)
        
        total_seconds += _calculate_night_overlap(s, e)
        
    return round(total_seconds / 3600.0, 2)

def calculate_saturday_sunday_hours(employee_id, year, month):
    start, end = date(year, month, 1), date(year, month, monthrange(year, month)[1])
    atts = Attendance.objects.filter(user_id=employee_id, date__range=(start, end)).distinct()
    
    sat, sun = 0.0, 0.0
    
    for att in atts:
        if att.type_shift and att.type_shift.id in NON_WORKING_SHIFT_IDS:
            continue

        if not (att.custom_start and att.custom_end): continue
        
        s, e = datetime.combine(att.date, att.custom_start), datetime.combine(att.date, att.custom_end)
        if e < s: e += timedelta(days=1)
        
        curr = s
        while curr < e:
            next_mid = datetime.combine(curr.date() + timedelta(days=1), time.min)
            seg_end = min(e, next_mid)
            dur = (seg_end - curr).total_seconds()
            
            if curr.weekday() == 5: sat += dur
            elif curr.weekday() == 6: sun += dur
            
            curr = seg_end
            
    return {"saturday_hours": round(sat/3600, 2), "sunday_hours": round(sun/3600, 2)}

def calculate_weekend_hours(employee_id, year, month):
    d = calculate_saturday_sunday_hours(employee_id, year, month)
    return d["saturday_hours"] + d["sunday_hours"]

def calculate_holiday_hours(employee_id, year, month):
    start, end = date(year, month, 1), date(year, month, monthrange(year, month)[1])
    holidays = {h[0] for h in CalendarDay.get_slovak_holidays(year)}
    atts = Attendance.objects.filter(user_id=employee_id, date__range=(start, end)).distinct()
    
    sec = 0.0
    for att in atts:
        if att.type_shift and att.type_shift.id in NON_WORKING_SHIFT_IDS:
            continue

        if not (att.custom_start and att.custom_end): continue
        
        s, e = datetime.combine(att.date, att.custom_start), datetime.combine(att.date, att.custom_end)
        if e < s: e += timedelta(days=1)
        
        curr = s
        while curr < e:
            next_mid = datetime.combine(curr.date() + timedelta(days=1), time.min)
            seg_end = min(e, next_mid)
            
            if curr.date() in holidays: 
                sec += (seg_end - curr).total_seconds()
                
            curr = seg_end
            
    return {"holiday_hours": round(sec/3600, 2)}


# ==========================================
# 3.1. VÝPOČTY Z PLÁNU (PlannedShifts)
# ==========================================

def calculate_planned_hours(employee_id, year, month):
    start, end = date(year, month, 1), date(year, month, monthrange(year, month)[1])
    plans = PlannedShifts.objects.filter(
        user_id=employee_id, 
        date__range=(start, end),
        hidden=False
    ).select_related('type_shift') 
    
    return round(sum(_get_duration(p) for p in plans), 2)

def calculate_planned_night_hours(employee_id, year, month):
    start, end = date(year, month, 1), date(year, month, monthrange(year, month)[1])
    plans = PlannedShifts.objects.filter(
        user_id=employee_id, 
        date__range=(start, end),
        hidden=False
    ).select_related('type_shift')
    
    total_seconds = 0.0
    for p in plans:
        if not (p.custom_start and p.custom_end): continue
        
        s = datetime.combine(p.date, p.custom_start)
        e = datetime.combine(p.date, p.custom_end)
        if e < s: e += timedelta(days=1)
        if p.custom_end == time(0, 0) and s == e: e += timedelta(days=1)
        
        total_seconds += _calculate_night_overlap(s, e)
        
    return round(total_seconds / 3600.0, 2)

def calculate_planned_weekend_hours(employee_id, year, month):
    start, end = date(year, month, 1), date(year, month, monthrange(year, month)[1])
    plans = PlannedShifts.objects.filter(
        user_id=employee_id, 
        date__range=(start, end),
        hidden=False
    ).select_related('type_shift')
    
    sat, sun = 0.0, 0.0
    for p in plans:
        if p.type_shift and p.type_shift.id in NON_WORKING_SHIFT_IDS:
            continue
        if not (p.custom_start and p.custom_end): continue
        
        s, e = datetime.combine(p.date, p.custom_start), datetime.combine(p.date, p.custom_end)
        if e < s: e += timedelta(days=1)
        
        curr = s
        while curr < e:
            next_mid = datetime.combine(curr.date() + timedelta(days=1), time.min)
            seg_end = min(e, next_mid)
            dur = (seg_end - curr).total_seconds()
            
            if curr.weekday() == 5: sat += dur
            elif curr.weekday() == 6: sun += dur
            
            curr = seg_end
            
    return {
        "saturday_hours": round(sat/3600, 2), 
        "sunday_hours": round(sun/3600, 2),
        "total_weekend": round((sat + sun)/3600, 2)
    }

def calculate_planned_holiday_hours(employee_id, year, month):
    start, end = date(year, month, 1), date(year, month, monthrange(year, month)[1])
    holidays = {h[0] for h in CalendarDay.get_slovak_holidays(year)}
    
    plans = PlannedShifts.objects.filter(
        user_id=employee_id, 
        date__range=(start, end),
        hidden=False
    ).select_related('type_shift')
    
    sec = 0.0
    for p in plans:
        if p.type_shift and p.type_shift.id in NON_WORKING_SHIFT_IDS:
            continue
        if not (p.custom_start and p.custom_end): continue
        
        s, e = datetime.combine(p.date, p.custom_start), datetime.combine(p.date, p.custom_end)
        if e < s: e += timedelta(days=1)
        
        curr = s
        while curr < e:
            next_mid = datetime.combine(curr.date() + timedelta(days=1), time.min)
            seg_end = min(e, next_mid)
            if curr.date() in holidays: 
                sec += (seg_end - curr).total_seconds()
            curr = seg_end
            
    return {"holiday_hours": round(sec/3600, 2)}

# ==========================================
# 4. SALDÁ A FINAL REPORT (OPRAVENÉ)
# ==========================================
# WorkTrackApi/services.py

def calculate_month_data(user, year, month):
    """
    Vypočíta presné dáta (worked, fund, diff...) pre jeden konkrétny mesiac.
    Slúži ako jednotný zdroj pravdy pre históriu aj aktuálny pohľad.
    """
    # 1. Fond
    fund = calculate_working_fund(year, month)

    # 2. Odpracované hodiny
    shifts = PlannedShifts.objects.filter(
        user=user,
        date__year=year,
        date__month=month,
        hidden=False
    ).select_related('type_shift')

    worked_hours = 0.0
    night_hours = 0.0
    weekend_hours = 0.0

    for s in shifts:
        duration = 0.0
        # Výpočet trvania
        if s.custom_start and s.custom_end:
            start_dt = datetime.combine(s.date, s.custom_start)
            end_dt = datetime.combine(s.date, s.custom_end)
            if end_dt < start_dt: end_dt += timedelta(days=1)
            elif s.custom_end == time(0,0) and start_dt != end_dt: end_dt += timedelta(days=1)
            duration = (end_dt - start_dt).total_seconds() / 3600.0
        elif s.type_shift and s.type_shift.duration_time:
            duration = float(s.type_shift.duration_time)

        worked_hours += duration

        # Víkendy
        if s.date.weekday() >= 5:
            weekend_hours += duration
        
        # Nočné
        if (s.type_shift and s.type_shift.shortName == 'Ns') or \
           (s.type_shift and 'Nočná' in s.type_shift.nameShift):
            night_hours += min(duration, 8)

    return {
        "fund": fund,
        "worked": worked_hours,
        "diff": worked_hours - fund,
        "night": night_hours,
        "weekend": weekend_hours
    }


def get_balances_up_to(target_year, target_month):
    """
    Vypočíta saldo k 1. dňu zadaného mesiaca pomocou calculate_month_data.
    """
    employees = Employees.objects.filter(is_active=True)
    balances = {}
    
    cutoff_date = date(target_year, target_month, 1)

    for emp in employees:
        try:
            current_balance = float(emp.initial_hours_balance or 0)

            # Nájdeme prvú smenu
            first_shift = PlannedShifts.objects.filter(
                user=emp, date__lt=cutoff_date, hidden=False
            ).order_by('date').first()

            if not first_shift:
                balances[emp.id] = round(current_balance, 2)
                continue

            # Iterujeme od mesiaca prvej smeny až po mesiac PRED cutoff_date
            cursor_date = date(first_shift.date.year, first_shift.date.month, 1)

            while cursor_date < cutoff_date:
                # 👇 TOTO JE KĽÚČOVÁ ZMENA: Voláme spoločnú funkciu
                month_stats = calculate_month_data(emp, cursor_date.year, cursor_date.month)
                
                # Pripočítame rozdiel (worked - fund) k saldu
                current_balance += month_stats['diff']

                # Posun na ďalší mesiac
                next_month = (cursor_date.replace(day=1) + timedelta(days=32)).replace(day=1)
                cursor_date = next_month

            balances[emp.id] = round(current_balance, 2)
            
        except Exception as e:
            print(f"Error calculating balance for {emp}: {e}")
            balances[emp.id] = 0

    return balances


def compare_worked_time_working_fund(employee_id, year, month):
    fund = calculate_working_fund(year, month)
    worked = calculate_worked_hours(employee_id, year, month)
    return {"working_fund": fund, "worked_hours": worked, "difference": round(worked - fund, 2)}

def calculate_transferred_hours(employee_id, year, month):
    # Táto funkcia ráta prenos z Attendance (dochádzky), 
    # zatiaľ čo get_balances_up_to ráta z PlannedShifts (plánu).
    # Záleží, čo chcete zobrazovať v plánovači. 
    # Pre plánovač zvyčajne chceme vidieť saldo z PLÁNU.
    try:
        emp = Employees.objects.get(id=employee_id)
        bal = float(emp.initial_hours_balance or 0)
    except: return 0.0
    
    first = Attendance.objects.filter(user_id=employee_id).order_by("date").first()
    if not first: return bal
    y, m = first.date.year, first.date.month
    if (y > year) or (y == year and m >= month): return bal
    
    curr_y, curr_m = y, m
    while (curr_y < year) or (curr_y == year and curr_m < month):
        f = calculate_working_fund(curr_y, curr_m)
        w = calculate_worked_hours(employee_id, curr_y, curr_m)
        c = calculate_paid_holiday_credit(employee_id, curr_y, curr_m)
        bal += (w + c) - f
        curr_y, curr_m = get_next_month(curr_y, curr_m)
    return round(bal, 2)

def calculate_total_hours_with_transfer(employee_id, year, month):
    fund = calculate_working_fund(year, month)
    worked = calculate_worked_hours(employee_id, year, month)
    credit = calculate_paid_holiday_credit(employee_id, year, month)
    
    wd = calculate_saturday_sunday_hours(employee_id, year, month)
    hd = calculate_holiday_hours(employee_id, year, month)
    nh = calculate_night_shift_hours(employee_id, year, month)

    curr_total = worked + credit
    diff = curr_total - fund
    transf = calculate_transferred_hours(employee_id, year, month)

    return {
        "year": year, "month": month, "working_fund": fund,
        "current_month_worked": worked, "holiday_credit": credit,
        "details": {
            "saturday_hours": wd["saturday_hours"],
            "sunday_hours": wd["sunday_hours"],
            "worked_on_holiday_hours": hd["holiday_hours"],
            "night_shift_hours": nh,
        },
        "current_month_total": curr_total,
        "current_month_diff": round(diff, 2),
        "transferred_hours": transf,
        "total_balance": round(transf + diff, 2)
    }

# ==========================================
# 5. KOPÍROVANIE PLÁNU
# ==========================================
def copy_monthly_plan(user, source_year, source_month, target_year, target_month):
    source_start = date(source_year, source_month, 1)
    source_end = date(source_year, source_month, monthrange(source_year, source_month)[1])
    
    source_shifts = PlannedShifts.objects.filter(
        user=user, 
        date__range=(source_start, source_end), 
        hidden=False
    )
    
    created_count = 0
    
    for shift in source_shifts:
        try:
            new_date = date(target_year, target_month, shift.date.day)
            
            if not PlannedShifts.objects.filter(user=user, date=new_date).exists():
                PlannedShifts.objects.create(
                    user=user,
                    date=new_date,
                    type_shift=shift.type_shift,
                    custom_start=shift.custom_start,
                    custom_end=shift.custom_end,
                    note=shift.note,
                    calendar_day=shift.calendar_day
                )
                created_count += 1
                
        except ValueError:
            pass
            
    return created_count

def get_planned_monthly_summary(user_id, year, month):
    start_date = date(year, month, 1)
    end_date = date(year, month, monthrange(year, month)[1])
    
    plans = PlannedShifts.objects.filter(
        user_id=user_id, 
        date__range=(start_date, end_date),
        hidden=False  
    )
    
    total_hours = 0.0
    
    for p in plans:
        if p.custom_start and p.custom_end:
            s = datetime.combine(p.date, p.custom_start)
            e = datetime.combine(p.date, p.custom_end)
            
            if e < s: e += timedelta(days=1)
            if p.custom_end == time(0, 0) and s != e: e += timedelta(days=1)
            
            total_hours += (e - s).total_seconds() / 3600.0
            
    return {"planned_hours": round(total_hours, 2)}

def get_full_monthly_stats(year, month):
    """
    Vráti štatistiky pre Plánovač.
    """
    # 1. Získame históriu (tá už teraz používa opravený výpočet)
    prev_balances = get_balances_up_to(year, month)
    
    employees = Employees.objects.filter(is_active=True)
    stats = []

    for emp in employees:
        # 2. Vypočítame aktuálny mesiac (znova cez spoločnú funkciu)
        month_data = calculate_month_data(emp, year, month)

        prev_balance = prev_balances.get(emp.id, 0.0)
        
        # 3. Spojíme to dokopy
        total_balance = prev_balance + month_data['diff']

        stats.append({
            "user_id": emp.id,
            "prevBalance": round(prev_balance, 2),
            "fund": round(month_data['fund'], 2),
            "worked": round(month_data['worked'], 2),
            "diff": round(month_data['diff'], 2),
            "total": round(total_balance, 2),
            "night": round(month_data['night'], 1),
            "weekend": round(month_data['weekend'], 1),
            "holiday": 0.0 
        })

    return stats
    """
    Vráti kompletnú štatistiku pre tabuľku v Plánovači.
    Kombinuje historický prenos (get_balances_up_to) s aktuálne naplánovanými hodinami.
    """
    # 1. Získame prenos z minulosti (použijeme funkciu, ktorú už máte)
    prev_balances = get_balances_up_to(year, month)

    # 2. Získame fond pre tento mesiac (použijeme funkciu, ktorú už máte)
    fund = calculate_working_fund(year, month) 

    # 3. Zoznam aktívnych zamestnancov
    employees = Employees.objects.filter(is_active=True)
    
    stats = []

    for emp in employees:
        # Odpracované v tomto mesiaci (z PlannedShifts, lebo sme v plánovači)
        shifts = PlannedShifts.objects.filter(
            user=emp,
            date__year=year,
            date__month=month,
            hidden=False
        ).select_related('type_shift') # Optimalizácia

        worked_hours = 0.0
        night_hours = 0.0
        weekend_hours = 0.0
        
        for s in shifts:
            # A. Výpočet trvania smeny (použijeme vašu logiku _get_duration alebo podobnú)
            duration = 0.0
            if s.custom_start and s.custom_end:
                start_dt = datetime.combine(s.date, s.custom_start)
                end_dt = datetime.combine(s.date, s.custom_end)
                
                if end_dt < start_dt:
                    end_dt += timedelta(days=1)
                elif s.custom_end == time(0,0) and start_dt != end_dt:
                     end_dt += timedelta(days=1)
                
                diff = (end_dt - start_dt).total_seconds() / 3600.0
                duration = diff
            elif s.type_shift and s.type_shift.duration_time:
                 duration = float(s.type_shift.duration_time)

            worked_hours += duration

            # B. Víkendy
            if s.date.weekday() >= 5: # 5=Sobota, 6=Nedeľa
                weekend_hours += duration
            
            # C. Nočné (Tu si upravte podmienku podľa toho, ako označujete nočné)
            # Napríklad kontrola názvu alebo času
            if (s.type_shift and s.type_shift.shortName == 'Ns') or \
               (s.type_shift and 'Nočná' in s.type_shift.nameShift):
                 night_hours += min(duration, 8) 

        # 4. Finálna matematika pre tabuľku
        prev_balance = prev_balances.get(emp.id, 0.0)
        diff = worked_hours - fund
        total_balance = prev_balance + diff

        stats.append({
            "user_id": emp.id,
            "prevBalance": round(prev_balance, 2),
            "fund": round(fund, 2),
            "worked": round(worked_hours, 2),
            "diff": round(diff, 2),
            "total": round(total_balance, 2),
            "night": round(night_hours, 1),
            "weekend": round(weekend_hours, 1),
            "holiday": 0.0 
        })

    return stats
</file>

<file path="WorkTrackApi/signals.py">
from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver
from .models import Attendance, PlannedShifts, ChangeReason
from rest_framework.authtoken.models import Token
from django.conf import settings


@receiver(post_save, sender=settings.AUTH_USER_MODEL)
def create_auth_token(sender, instance=None, created=False, **kwargs):
    if created:
        Token.objects.create(user=instance)

@receiver(post_save, sender=Attendance)
def mark_planned_shift_transferred_on_save(sender, instance, created, **kwargs):
    if created:
        planned = instance.planned_shift
        if planned and not planned.transferred:
            planned.transferred = True
            planned.save(update_fields=['transferred'])

@receiver(post_delete, sender=Attendance)
def unmark_planned_shift_transferred_on_delete(sender, instance, **kwargs):
    if not Attendance.objects.filter(user=instance.user, date=instance.date).exists():
        planned = instance.planned_shift
        if planned and planned.transferred:
            planned.transferred = False
            planned.note=""
            planned.save(update_fields=['transferred','note'])
@receiver(post_save, sender=Attendance)
def mark_planned_shift_transferred_on_save(sender, instance, created, **kwargs):
    """
    Keď sa vytvorí/upraví dochádzka, označí priradenú plánovanú smenu ako 'transferred' (odrobenú).
    """
    if created:
        planned = instance.planned_shift
        if planned and not planned.transferred:
            planned.transferred = True
            planned.save(update_fields=['transferred'])

@receiver(post_delete, sender=Attendance)
def handle_planned_shift_on_delete(sender, instance, **kwargs):
    
    """
    Rieši čo sa stane s Plánom, keď sa vymaže Dochádzka.
    """
    planned = instance.planned_shift
    
    if not planned:
        return

    # 1. SCENÁR: Zmazanie EXTRA smeny (ID 22)
    # Ak bola dochádzka naviazaná na "Innú činnosť" (ID 22), ktorá vznikla automaticky,
    # chceme zmazať aj ten plán, aby tam neostalo "smeti".
    if planned.type_shift and planned.type_shift.id == 22:
        print(f"🗑️ Zmazaná automatická extra smena {planned.id} po zmazaní dochádzky.")
        planned.delete() # Úplné vymazanie z DB
        return

    # 2. SCENÁR: Zmazanie BEŽNEJ smeny (napr. ID 15, 20...)
    # Ak sme zmazali dochádzku k bežnej smene, chceme smenu len "odznačiť" (transferred = False),
    # aby svietila, že ju treba znova odrobiť.
    # Kontrolujeme, či k tomuto plánu neexistuje ešte iná dochádzka (napr. pri duplicite).
    if not Attendance.objects.filter(planned_shift=planned).exists():
        if planned.transferred:
            planned.transferred = False
            # Nemazeme 'note', lebo tam moze byt dolezita poznamka od managera
            planned.save(update_fields=['transferred'])
            print(f"backtrack: Plánovaná smena {planned.id} vrátená do stavu transferred=False")






from django.utils import timezone
from .models import Employees

@receiver(post_save, sender=Employees)
def cleanup_future_shifts_on_deactivation(sender, instance, created, **kwargs):
    """
    Spustí sa automaticky po každom uložení modelu Employees.
    Ak je zamestnanec nastavený na is_active=False, zmaže jeho budúce smeny.
    """
    # Kontrolujeme, či je zamestnanec neaktívny
    if not instance.is_active:
        today = timezone.now().date()
        
        # Nájdeme všetky smeny, ktoré sú v budúcnosti (od zajtra)
        # Dnešok necháme tak, ak by náhodou ešte pracoval
        future_shifts = PlannedShifts.objects.filter(
            user=instance,
            date__gt=today
        )
        
        count = future_shifts.count()
        
        if count > 0:
            # --- MOŽNOSŤ A: ÚPLNÉ ZMAZANIE (Odporúčané) ---
            future_shifts.delete()
            print(f"🧹 SIGNAL: Zamestnanec {instance} deaktivovaný. Zmazaných {count} budúcich smien.")

            # --- MOŽNOSŤ B: LEN SKRYTIE (Alternatíva) ---
            # Ak si chcete nechať históriu, že "mal mať smenu", ale zrušila sa:
            # future_shifts.update(
            #     hidden=True, 
            #     is_changed=True, 
            #     note="ZRUŠENÉ: Zamestnanec deaktivovaný"
            # )
            # print(f"🙈 SIGNAL: Skrytých {count} budúcich smien pre {instance}.")
</file>

<file path="WorkTrackApi/tests.py">
from django.test import TestCase
from rest_framework.test import APIClient
from datetime import date, time
from .models import Employees, TypeShift, PlannedShifts

class ErrorMessagesTest(TestCase):
    def setUp(self):
        """
        Príprava dát pred každým testom.
        """
        # 1. Nastavenie API klienta a prihlásenie manažéra
        self.client = APIClient()
        self.user = Employees.objects.create(
            username="manazer", 
            role="manager", 
            personal_number="111"
        )
        self.client.force_authenticate(user=self.user) 
        
        # 2. Vytvorenie typu smeny (Ranná)
        # --- TU BOLA CHYBA: Doplnil som duration_time=8.0 ---
        self.ranna = TypeShift.objects.create(
            nameShift="Ranná", 
            start_time=time(6, 0), 
            end_time=time(14, 0),
            duration_time=8.0  # <--- TOTO JE POVINNÉ POLE
        )
        
        # 3. Vytvorenie prvej (existujúcej) smeny v DB
        PlannedShifts.objects.create(
            user=self.user, 
            date=date(2025, 4, 5), 
            type_shift=self.ranna
        )

    def test_conflict_error_message(self):
        """
        Testuje, či backend vráti 400 a správny text, keď sa smeny prekrývajú.
        """
        
        # Pokúsime sa vytvoriť NOVÚ smenu v ten istý čas pre toho istého usera
        data = {
            "user": self.user.id,
            "date": "2025-04-05",     # Rovnaký deň
            "type_shift": self.ranna.id # Rovnaký čas (6:00 - 14:00)
        }
        
        # Pošleme POST na vytvorenie
        response = self.client.post('/api/plannedshift/', data)
        
        # --- OVERENIA ---
        
        # 1. Musí vrátiť chybu 400 Bad Request
        self.assertEqual(response.status_code, 400, f"Očakával som 400, prišlo {response.status_code}. Data: {response.data}")
        
        # 2. Musí obsahovať kľúč 'non_field_errors' (tam sme to v serializeri poslali)
        self.assertIn("non_field_errors", response.data)
        
        # 3. Text chyby musí obsahovať naše slovo "Konflikt"
        error_msg = response.data["non_field_errors"][0]
        
        self.assertIn("Konflikt: Zamestnanec už má smenu", error_msg)
        self.assertIn("Ranná", error_msg) # Malo by tam byť aj meno kolíznej smeny
</file>

<file path="WorkTrackApi/urls.py">
from django.urls import path, include 
from rest_framework import routers 
from .views import EmployeesViewSet,TypeShiftViewSet,AttendanceViewSet, PlannerShiftsViewSet,ChangeReasonViewSet,CalendarDayViewSet,WorkingFundAPIView, MonthlyBalancesAPIView,WorkedHoursAPIView,SaturdaySundayHoursApiView,WeekendHoursApiView,HolidayHoursApiView,CompareHoursApiView,TotalHoursApiView,NightShiftHoursApiView,CustomAuthToken,CurrentUserView,TestView,ActiveUserListView,PlannedHoursSummaryView, MonthlyStatsView

router=routers.DefaultRouter() 
router.register(r'employees', EmployeesViewSet)
router.register(r'typeshift', TypeShiftViewSet)
router.register(r'attendance', AttendanceViewSet)
router.register(r'plannedshift', PlannerShiftsViewSet)
router.register(r'changereason', ChangeReasonViewSet)
router.register(r'calendarday', CalendarDayViewSet)



urlpatterns = [ 
    path('plannedshift/stats/', MonthlyStatsView.as_view(), name='monthly-stats'),
    path('balances/<int:year>/<int:month>/', MonthlyBalancesAPIView.as_view()),
    path('api-token-auth/', CustomAuthToken.as_view(), name='api-token-auth'),
    path('active-users/', ActiveUserListView.as_view(), name='active-users'),
    path('total-hours/<int:employee_id>/<int:year>/<int:month>/', TotalHoursApiView.as_view(), name='total-hours-report'),
    path('planned-hours/<int:employee_id>/<int:year>/<int:month>/', PlannedHoursSummaryView.as_view()),
    path('api/test/', TestView.as_view()),  
    path('', include(router.urls)), 
    path('current-user/', CurrentUserView.as_view(), name='current-user'),
    path('working_fund/<int:year>/<int:month>/', WorkingFundAPIView.as_view(), name='working-fund'),
    path('worked_hours/<int:employee_id>/<int:year>/<int:month>/', WorkedHoursAPIView.as_view(), name='worked-hours'),
    path('saturday_sunday_hours/<int:employee_id>/<int:year>/<int:month>/', SaturdaySundayHoursApiView.as_view(), name='saturday-sunday-hours'),
    path('weekend_hours/<int:employee_id>/<int:year>/<int:month>/', WeekendHoursApiView.as_view(), name='weekend-hours'),
    path('holiday_hours/<int:employee_id>/<int:year>/<int:month>/', HolidayHoursApiView.as_view(), name='holiday-hours'),
    path('compare_hours/<int:employee_id>/<int:year>/<int:month>/', CompareHoursApiView.as_view(), name='compare-hours'),
    path('total_hours/<int:employee_id>/<int:year>/<int:month>/', TotalHoursApiView.as_view(), name='total-hours'),
    path('night_shift_hours/<int:employee_id>/<int:year>/<int:month>/', NightShiftHoursApiView.as_view(), name='night-shift-hours'),


]
</file>

<file path="WorkTrackApi/utils/__init__.py">

</file>

<file path="WorkTrackApi/utils/attendance_utils.py">
from datetime import datetime, timedelta, time
from django.core.exceptions import ValidationError

# ==========================================
# ZÁKLADNÉ UTILITY
# ==========================================

def round_to_nearest_half_hour(t: time) -> time:
    dt = datetime.combine(datetime.today(), t)
    minute = dt.minute
    down = minute % 30
    up = 30 - down
    if down < up:
        dt_rounded = dt - timedelta(minutes=down)
    else:
        dt_rounded = dt + timedelta(minutes=up)
    return dt_rounded.time()

def create_attendance_from_planned_shift(user, date, planned_shift_id):
    from WorkTrackApi.models import PlannedShifts, Attendance
    planned_shift = PlannedShifts.objects.filter(
        id=planned_shift_id,
        user=user,
        date=date,
        hidden=False,
    ).first()

    if not planned_shift:
        return None

    attendance = Attendance.objects.create(
        user=user,
        date=planned_shift.date,
        custom_start=planned_shift.custom_start,
        custom_end=planned_shift.custom_end,
        type_shift=planned_shift.type_shift,
        planned_shift=planned_shift,
        note=planned_shift.note or "Vytvorená dochádzka na základe plánovanej smeny",
    )
    return attendance

def prevziat_smenu_logic(request_user, target_shift_id, user_id=None, note=None):
    from WorkTrackApi.models import PlannedShifts, Attendance, Employees
    try:
        target_shift = PlannedShifts.objects.get(pk=target_shift_id)
    except PlannedShifts.DoesNotExist:
        return None, "Plánovaná smena neexistuje."

    if request_user.role in ['admin', 'manager'] and user_id:
        try:
            user_to_assign = Employees.objects.get(pk=user_id)
        except Employees.DoesNotExist:
            return None, "Používateľ neexistuje."
    else:
        user_to_assign = request_user

    attendance = Attendance.objects.create(
        user=user_to_assign,
        date=target_shift.date,
        type_shift=target_shift.type_shift,
        custom_start=target_shift.custom_start,
        custom_end=target_shift.custom_end,
        note=note or f"Preberám smenu od {target_shift.user}",
    )
    exchange_shift_logic(attendance, target_shift)
    return attendance, None

def exchange_shift_logic(attendance, target_shift):
    from WorkTrackApi.models import PlannedShifts
    if not target_shift:
        raise ValidationError("Nebola vybraná smena na výmenu.")
    if attendance.user == target_shift.user:
        raise ValidationError("Nemôžeš si vymeniť smenu sám so sebou.")
    if attendance.date != target_shift.date or attendance.type_shift != target_shift.type_shift:
        raise ValidationError("Smena na výmenu musí byť rovnakého typu a dňa.")

    new_shift = PlannedShifts.objects.create(
        user=attendance.user,
        date=attendance.date,
        type_shift=attendance.type_shift,
        custom_start=attendance.custom_start,
        custom_end=attendance.custom_end,
        transferred=True,
        is_changed=True,
        note=f"Pozor Výmena smeny s {target_shift.user} – treba zadať dôvod"
    )
    target_shift.hidden = True
    target_shift.save(update_fields=["hidden"])
    attendance.exchanged_with = new_shift
    attendance.save()
    print(f"🔁 Výmena smeny: {attendance.user} ↔ {target_shift.user}")

# ==========================================
# NOČNÉ SMENY
# ==========================================

def split_night_planned_shift(planned_shift):
    from WorkTrackApi.models import PlannedShifts
    if not (planned_shift.type_shift and planned_shift.type_shift.id == 20):
        return

    start = planned_shift.custom_start
    end = planned_shift.custom_end
    midnight = time(0, 0)
    
    if end == midnight:
        return

    planned_shift.custom_end = midnight
    planned_shift.save(update_fields=['custom_end'])
    print(f"✂️ Plánovaná smena {planned_shift.id} skrátená do polnoci.")

    next_day = planned_shift.date + timedelta(days=1)
    exists = PlannedShifts.objects.filter(
        user=planned_shift.user,
        date=next_day,
        custom_start=midnight,
        type_shift=planned_shift.type_shift,
        hidden=False
    ).exists()

    if not exists:
        PlannedShifts.objects.create(
            user=planned_shift.user,
            date=next_day,
            custom_start=midnight,
            custom_end=end,
            type_shift=planned_shift.type_shift,
            calendar_day=None,
            note=f"{planned_shift.note} (pokračovanie)",
            transferred=planned_shift.transferred,
            is_changed=planned_shift.is_changed,
            hidden=False
        )
        print(f"➕ Vytvorená druhá časť plánu na {next_day}")

def handle_night_shift(attendance):
    from WorkTrackApi.models import Attendance, PlannedShifts
    
    # 1. Kontrola typu smeny
    if not (attendance.type_shift and attendance.type_shift.id == 20):
        return

    midnight = time(0, 0)
    start = attendance.custom_start
    end = attendance.custom_end

    # 2. Zistíme, či smena prechádza cez polnoc
    if start > end or end == midnight:
        
        real_end_time = end 
        
        # A) Orezať prvú časť
        if end != midnight:
            print(f"✂️ Delím dochádzku {attendance.id} (pôvodne do {end}) na polnoc.")
            attendance.custom_end = midnight
            attendance.save(update_fields=['custom_end'])
        
        # B) Druhá časť
        next_day = attendance.date + timedelta(days=1)
        
        if Attendance.objects.filter(user=attendance.user, date=next_day, custom_start=midnight).exists():
            return

        next_part_plan = PlannedShifts.objects.filter(
            user=attendance.user, date=next_day, type_shift=attendance.type_shift,
            custom_start=midnight, hidden=False, transferred=False 
        ).first()

        new_att = None
        if next_part_plan:
            print(f"🔗 Automaticky preklápam druhú časť nočnej smeny (ID plánu: {next_part_plan.id})")
            final_end = real_end_time if real_end_time != midnight else next_part_plan.custom_end
            new_att = Attendance.objects.create(
                user=attendance.user, date=next_day, type_shift=attendance.type_shift,
                planned_shift=next_part_plan, custom_start=next_part_plan.custom_start,
                custom_end=final_end, note="Pokračovanie nočnej smeny (podľa plánu)"
            )
        else:
            print("⚠️ Nenájdený plán pre 2. časť, vytváram voľný Attendance.")
            final_end = real_end_time if real_end_time != midnight else time(9, 0)
            new_att = Attendance.objects.create(
                user=attendance.user, date=next_day, type_shift=attendance.type_shift,
                custom_start=midnight, custom_end=final_end, note="Pokračovanie nočnej smeny (bez plánu)"
            )

        # C) Kontrola nadčasov na druhej časti
        if new_att:
            handle_end_shift_time(new_att)

# ==========================================
# RIEŠENIE ČASOV (Skorší príchod / Neskorší odchod)
# ==========================================

# WorkTrackApi/utils/attendance_utils.py

def handle_start_shift_time(attendance_instance):
    from WorkTrackApi.models import PlannedShifts, Attendance, TypeShift, ChangeReason

    # Nájdeme plánovanú smenu prepojenú s touto dochádzkou
    planned_shift = attendance_instance.planned_shift
    if not planned_shift: return 

    # Časy z dochádzky (realita) a plánu
    real_start = attendance_instance.custom_start
    plan_start = planned_shift.custom_start

    if not (real_start and plan_start): return

    # --- SCENÁR A: SKORŠÍ PRÍCHOD (Nadčas) -> NOVÁ SMENA ---
    if real_start < plan_start:
        print(f"🟢 Skorší príchod: Vytváram Inú činnosť (Extra)")

        try:
            type_shift_extra = TypeShift.objects.get(id=22) # Iná činnosť
        except TypeShift.DoesNotExist: return

        # Zoberieme dôvod z pôvodného plánu (ak bol nastavený v serializeri) alebo default
        reason = planned_shift.change_reason 

        # Prevencia duplicít
        if PlannedShifts.objects.filter(
            user=attendance_instance.user, date=attendance_instance.date,
            custom_start=real_start, custom_end=plan_start,
            type_shift=type_shift_extra
        ).exists(): return

        # 1. Vytvoríme EXTRA PLÁN (Typ 22)
        extra_plan = PlannedShifts.objects.create(
            user=attendance_instance.user, date=attendance_instance.date,
            custom_start=real_start, custom_end=plan_start,
            type_shift=type_shift_extra, transferred=True, is_changed=True,
            change_reason=reason, approval_status='pending',
            note="Automaticky: Skorší príchod",
            calendar_day=planned_shift.calendar_day,
        )
        
        # 2. Vytvoríme EXTRA DOCHÁDZKU k tomu plánu
        Attendance.objects.create(
            user=attendance_instance.user, date=attendance_instance.date,
            planned_shift=extra_plan, custom_start=real_start, custom_end=plan_start,
            type_shift=type_shift_extra, note="Auto: Skorší príchod",
            calendar_day=extra_plan.calendar_day,
        )
        
        # 3. Pôvodnú dochádzku zarovnáme na plán (aby sa neprekrývala)
        # Poznámka: Pôvodný plán nemeníme, lebo ten platí od svojho začiatku
        attendance_instance.custom_start = plan_start
        attendance_instance.save(update_fields=['custom_start'])

    # --- SCENÁR B: NESKORÝ PRÍCHOD (Meškanie) -> ÚPRAVA PLÁNU ---
    elif real_start > plan_start:
        print(f"🔻 Neskorý príchod: Krátim pôvodný plán")
        
        # Tu len potvrdíme zmeny v pláne
        planned_shift.custom_start = real_start
        planned_shift.is_changed = True
        # change_reason už bol nastavený v serializeri, tu ho len potvrdíme ak treba
        if not planned_shift.change_reason:
             # Fallback ak by nebol (napr. ID 9)
             pass 
        
        planned_shift.note = (planned_shift.note or "") + " (Krátené pre meškanie)"
        planned_shift.save(update_fields=['custom_start', 'is_changed', 'note'])


def handle_end_shift_time(attendance_instance):
    from WorkTrackApi.models import PlannedShifts, Attendance, TypeShift

    planned_shift = attendance_instance.planned_shift
    if not planned_shift: return 

    real_end = attendance_instance.custom_end
    plan_end = planned_shift.custom_end

    if not (real_end and plan_end): return

    # --- SCENÁR A: NESKORŠÍ ODCHOD (Nadčas) -> NOVÁ SMENA ---
    if real_end > plan_end:
        print(f"🟢 Neskorší odchod: Vytváram Inú činnosť (Extra)")
        try: type_shift_extra = TypeShift.objects.get(id=22)
        except: return

        reason = planned_shift.change_reason

        if PlannedShifts.objects.filter(
            user=attendance_instance.user, date=attendance_instance.date,
            custom_start=plan_end, custom_end=real_end, type_shift=type_shift_extra
        ).exists(): return

        extra_plan = PlannedShifts.objects.create(
            user=attendance_instance.user, date=attendance_instance.date,
            custom_start=plan_end, custom_end=real_end,
            type_shift=type_shift_extra, transferred=True, is_changed=True,
            change_reason=reason, approval_status='pending',
            note="Automaticky: Neskorší odchod",
            calendar_day=planned_shift.calendar_day,
        )

        Attendance.objects.create(
            user=attendance_instance.user, date=attendance_instance.date,
            planned_shift=extra_plan, custom_start=plan_end, custom_end=real_end,
            type_shift=type_shift_extra, note="Auto: Neskorší odchod",
            calendar_day=extra_plan.calendar_day,
        )

        attendance_instance.custom_end = plan_end
        attendance_instance.save(update_fields=['custom_end'])

    # --- SCENÁR B: SKORŠÍ ODCHOD (Útek) -> ÚPRAVA PLÁNU ---
    elif real_end < plan_end:
        print(f"🔻 Skorší odchod: Krátim pôvodný plán")
        planned_shift.custom_end = real_end
        planned_shift.is_changed = True
        planned_shift.note = (planned_shift.note or "") + " (Krátené pre odchod)"
        planned_shift.save(update_fields=['custom_end', 'is_changed', 'note'])
def handle_any_shift_time(attendance_instance):
    handle_start_shift_time(attendance_instance)
    handle_end_shift_time(attendance_instance)
</file>

<file path="WorkTrackApi/views.py">
# Súbor: WorkTrackApi/views.py

from rest_framework import viewsets, permissions, status, generics
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.decorators import action
from rest_framework.permissions import AllowAny, IsAuthenticated, IsAdminUser
from rest_framework.exceptions import PermissionDenied, ValidationError
from rest_framework.authtoken.views import ObtainAuthToken
from rest_framework.authtoken.models import Token
from rest_framework.authentication import TokenAuthentication

from django.db import transaction
from django.utils.dateparse import parse_time
from datetime import date, datetime, time, timedelta
from calendar import monthrange

# Importy modelov a serializerov
from .models import Employees, TypeShift, Attendance, PlannedShifts, ChangeReason, CalendarDay
from .serializers import (
    BulkRosterSerializer, EmployeesSerializer, TypeShiftSerializer, 
    AttendanceSerializer, PlannedShiftsSerializer, ChangeReasonSerializers, 
    CalendarDaySerializers
)
from .export import MonthlyRosterExporter, AttendancePdfExporter, VacationFormExporter
from .permissions import IsManagerOrReadOnly

# DÔLEŽITÉ: Import všetkých servisných funkcií
from .services import (
    calculate_working_fund, calculate_worked_hours, calculate_saturday_sunday_hours,
    calculate_weekend_hours, calculate_holiday_hours, compare_worked_time_working_fund,
    calculate_total_hours_with_transfer, calculate_night_shift_hours, copy_monthly_plan,
    get_planned_monthly_summary, get_balances_up_to, get_full_monthly_stats
)

from WorkTrackApi.utils.attendance_utils import (
    split_night_planned_shift, handle_night_shift, 
    handle_start_shift_time, handle_end_shift_time
)

# ==========================================
# 1. ŠPECIÁLNE ENDPOINTY (Stats, Dashboard, Auth)
# ==========================================

class MonthlyStatsView(APIView):
    """
    Endpoint: /api/plannedshift/stats/?year=2025&month=1
    """
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request):
        try:
            year = int(request.query_params.get('year'))
            month = int(request.query_params.get('month'))
            data = get_full_monthly_stats(year, month)
            return Response(data)
        except (ValueError, TypeError):
            return Response({"error": "Invalid year or month"}, status=400)

class MonthlyBalancesAPIView(APIView):
    def get(self, request, year, month):
        balances = get_balances_up_to(year, month)
        return Response(balances)

class WorkingFundAPIView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request, year: int, month: int):
        fund = calculate_working_fund(year, month)
        holidays_query = CalendarDay.objects.filter(
            date__year=year, date__month=month, is_holiday=True
        )
        holiday_days = [h.date.day for h in holidays_query]
        return Response({
            "year": year, "month": month,
            "working_fund_hours": fund,
            "holidays": holiday_days
        })

class DashboardView(APIView):
    authentication_classes = [TokenAuthentication]
    permission_classes = [permissions.IsAuthenticated]
    def get(self, request):
        return Response({"message": f"Ahoj {request.user.username}, toto je tvoj dashboard"})

class TestView(APIView):
    permission_classes = [permissions.IsAuthenticated]
    def get(self, request):
        return Response({"message": "OK"})

class ActiveUserListView(generics.ListAPIView):
    serializer_class = EmployeesSerializer
    def get_queryset(self):
         return Employees.objects.all().prefetch_related('planned_shifts')

class CurrentUserView(APIView):
    permission_classes = [permissions.IsAuthenticated]
    def get(self, request):
        serializer = EmployeesSerializer(request.user)
        return Response(serializer.data)

class CustomAuthToken(ObtainAuthToken):
    def post(self, request, *args, **kwargs):
        serializer = self.serializer_class(data=request.data, context={'request': request})
        serializer.is_valid(raise_exception=True)
        user = serializer.validated_data['user']
        token, _ = Token.objects.get_or_create(user=user)
        return Response({
            'token': token.key, 'user_id': user.id,
            'username': user.username, 'role': user.role
        })

# ==========================================
# 2. VIEWSETS (CRUD Operácie)
# ==========================================

class PlannerShiftsViewSet(viewsets.ModelViewSet):
    queryset = PlannedShifts.objects.all()
    serializer_class = PlannedShiftsSerializer
    permission_classes = [IsManagerOrReadOnly]

    def get_queryset(self):
        user = self.request.user
        if user.is_anonymous: return PlannedShifts.objects.none()
        
        queryset = PlannedShifts.objects.filter(hidden=False)
        if user.role == 'worker':
            queryset = queryset.filter(user=user)
        
        month = self.request.query_params.get('month')
        year = self.request.query_params.get('year')
        user_id_param = self.request.query_params.get('user')
        
        if month and year:
            queryset = queryset.filter(date__year=year, date__month=month)
        if user_id_param:
            queryset = queryset.filter(user_id=user_id_param)
        return queryset

    def create(self, request, *args, **kwargs):
        is_many = isinstance(request.data, list)
        serializer = self.get_serializer(data=request.data, many=is_many)
        serializer.is_valid(raise_exception=True)
        self.perform_create(serializer)
        headers = self.get_success_headers(serializer.data)
        return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)

    def perform_create(self, serializer):
        created_data = serializer.save()
        if isinstance(created_data, list):
            for shift in created_data:
                if shift.type_shift and shift.type_shift.id == 20:
                    split_night_planned_shift(shift)
        else:
            if created_data.type_shift and created_data.type_shift.id == 20:
                split_night_planned_shift(created_data)

    def perform_update(self, serializer):
        planned_shift = serializer.save()
        if planned_shift.type_shift and planned_shift.type_shift.id == 20:
            split_night_planned_shift(planned_shift)

    def destroy(self, request, *args, **kwargs):
        instance = self.get_object()
        instance.hidden = True
        instance.save()
        return Response({"detail": "Smena bola skrytá."}, status=status.HTTP_200_OK)

    @action(detail=False, methods=['post'], url_path='save-roster-matrix')
    def save_roster_matrix(self, request):
        serializer = BulkRosterSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        data = serializer.validated_data
        year, month, shifts_data = data['year'], data['month'], data['shifts']
        
        saved_count = 0
        try:
            with transaction.atomic():
                for item in shifts_data:
                    shift_date = item['date']
                    if shift_date.year != year or shift_date.month != month: continue

                    if item.get('type_shift_id') is None:
                        PlannedShifts.objects.filter(user_id=item['user_id'], date=shift_date).delete()
                        continue

                    defaults = {
                        'type_shift_id': item['type_shift_id'],
                        'custom_start': item.get('custom_start'),
                        'custom_end': item.get('custom_end'),
                        'note': item.get('note', ''),
                        'hidden': False
                    }
                    if not defaults['custom_start']:
                        ts = TypeShift.objects.get(id=item['type_shift_id'])
                        defaults['custom_start'] = ts.start_time
                        defaults['custom_end'] = ts.end_time

                    shift, _ = PlannedShifts.objects.update_or_create(
                        user_id=item['user_id'], date=shift_date, defaults=defaults
                    )
                    if shift.type_shift and shift.type_shift.id == 20:
                        split_night_planned_shift(shift)
                    saved_count += 1
            return Response({"detail": f"Uložených {saved_count} záznamov."}, status=200)
        except Exception as e:
            return Response({"error": str(e)}, status=500)

    @action(detail=False, methods=['get'], url_path='export-complex-roster')
    def export_complex_roster(self, request):
        try:
            year = int(request.query_params.get('year', 2025))
            month = int(request.query_params.get('month', 4))
        except ValueError:
            return Response({"error": "Chyba parametrov"}, status=400)
        exporter = MonthlyRosterExporter(year, month)
        return exporter.generate_response()

    @action(detail=False, methods=['get'], url_path='export-vacation-forms')
    def export_vacation_forms(self, request):
        try:
            year = int(request.query_params.get('year'))
            month = int(request.query_params.get('month'))
            user_id = int(request.query_params.get('user_id'))
        except (TypeError, ValueError):
             return Response({"error": "Chýbajú parametre"}, status=400)
        exporter = VacationFormExporter(user_id, year, month)
        return exporter.generate_response()
    
    @action(detail=False, methods=['post'])
    def copy_plan(self, request):
        s_year = request.data.get('source_year')
        s_month = request.data.get('source_month')
        t_year = request.data.get('target_year')
        t_month = request.data.get('target_month')
        user_id = request.data.get('user_id')

        if not all([s_year, s_month, t_year, t_month]):
            return Response({"error": "Chýbajú povinné údaje."}, status=400)

        try:
            result = copy_monthly_plan(int(s_year), int(s_month), int(t_year), int(t_month), user_id)
            return Response({"detail": "Plán skopírovaný.", "stats": result}, status=200)
        except Exception as e:
            return Response({"error": str(e)}, status=500)

    @action(detail=False, methods=['get'], url_path='summary/(?P<user_id>\d+)/(?P<year>\d+)/(?P<month>\d+)')
    def monthly_summary(self, request, user_id=None, year=None, month=None):
        if not user_id or not year or not month:
            return Response({"error": "Chýbajú parametre"}, status=400)
        try:
            summary_data = get_planned_monthly_summary(int(user_id), int(year), int(month))
            return Response(summary_data)
        except Exception as e:
            return Response({"error": str(e)}, status=500)

class EmployeesViewSet(viewsets.ModelViewSet):
    queryset = Employees.objects.all()
    serializer_class = EmployeesSerializer
    permission_classes = [permissions.IsAuthenticated]
    def get_queryset(self):
        user = self.request.user
        if user.role == 'worker': return Employees.objects.filter(id=user.id)
        return Employees.objects.all()

class TypeShiftViewSet(viewsets.ModelViewSet):
    queryset = TypeShift.objects.all()
    serializer_class = TypeShiftSerializer
    permission_classes = [permissions.IsAuthenticated]
    def perform_create(self, serializer):
        if self.request.user.role == 'worker': raise PermissionDenied()
        serializer.save()

class AttendanceViewSet(viewsets.ModelViewSet):
    queryset = Attendance.objects.all()
    serializer_class = AttendanceSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    @action(detail=False, methods=['get'], url_path='export-attendance-pdf')
    def export_attendance_pdf(self, request):
        try:
            year = int(request.query_params.get('year'))
            month = int(request.query_params.get('month'))
            user_id = int(request.query_params.get('user_id'))
            exporter = AttendancePdfExporter(user_id, year, month)
            return exporter.generate_response()
        except: return Response({"error": "Chyba parametrov"}, status=400)

    def get_queryset(self):
        if self.request.user.role == 'worker': 
            return Attendance.objects.filter(user=self.request.user)
        return Attendance.objects.all()

    def perform_create(self, serializer):
        instance = serializer.save()
        if instance.type_shift:
            if instance.type_shift.id == 20: handle_night_shift(instance)
            handle_start_shift_time(instance)
            handle_end_shift_time(instance)

    def perform_update(self, serializer):
        instance = serializer.save()
        if instance.type_shift:
            handle_start_shift_time(instance)
            handle_end_shift_time(instance)

class ChangeReasonViewSet(viewsets.ModelViewSet):
    queryset = ChangeReason.objects.all()
    serializer_class = ChangeReasonSerializers
    permission_classes = [permissions.IsAuthenticated]

class CalendarDayViewSet(viewsets.ModelViewSet):
    queryset = CalendarDay.objects.all()
    serializer_class = CalendarDaySerializers
    permission_classes = [permissions.IsAuthenticated]

# ==========================================
# 4. API VIEWS PRE REPORTY (Pôvodné - teraz kompletné)
# ==========================================

class BaseWorkedHoursAPIView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def calculate_hours(self, employee_id, year, month):
        raise NotImplementedError("Potomok musí implementovať calculate_hours")

    def get(self, request, employee_id, year, month):
        user = request.user
        if user.role == "worker" and user.id != employee_id:
            return Response({"detail": "Nemáš oprávnenie vidieť údaje iných."}, status=403)

        hours = self.calculate_hours(employee_id, year, month)
        return Response({"worked_hours": hours})

class WorkedHoursAPIView(BaseWorkedHoursAPIView):
    def calculate_hours(self, employee_id, year, month):
        return calculate_worked_hours(employee_id, year, month)

class SaturdaySundayHoursApiView(BaseWorkedHoursAPIView):
    def calculate_hours(self, employee_id, year, month):
        return calculate_saturday_sunday_hours(employee_id, year, month)

class WeekendHoursApiView(BaseWorkedHoursAPIView):
    def calculate_hours(self, employee_id, year, month):
        return calculate_weekend_hours(employee_id, year, month)

class CompareHoursApiView(BaseWorkedHoursAPIView):
    def calculate_hours(self, employee_id, year, month):
        return compare_worked_time_working_fund(employee_id, year, month)

class HolidayHoursApiView(BaseWorkedHoursAPIView):
    def calculate_hours(self, employee_id, year, month):
        return calculate_holiday_hours(employee_id, year, month)

class TotalHoursApiView(BaseWorkedHoursAPIView):
    def calculate_hours(self, employee_id, year, month):
        return calculate_total_hours_with_transfer(employee_id, year, month)

class NightShiftHoursApiView(BaseWorkedHoursAPIView):
    def calculate_hours(self, employee_id, year, month):
        return calculate_night_shift_hours(employee_id, year, month)

class PlannedHoursSummaryView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request, employee_id, year, month):
        data = get_planned_monthly_summary(employee_id, year, month)
        return Response(data)
</file>

</files>
